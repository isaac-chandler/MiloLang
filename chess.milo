#import "Windows"
#import "GL"
#import "Standard"
#import "Random"
#import "Bitmap"
#import "File"
#import "String"
#import "Thread"

should_quit: bool

window_width: s32 = 800
window_height: s32 = 800

load_image :: (filename: string) -> u32 {	
	file, success := read_entire_file(filename)
	defer deallocate(file.data)
	
	if !success {
		print("Failed to load image ")
		print(filename)
		print("\n")
		return 0
	}
	
	if file.count < size_of(Bmp_File_Header) + size_of(Bmp_Dib_Header) {
		return 0
	}

	file_header := cast(*Bmp_File_Header)file.data
	dib_header := cast(*Bmp_Dib_Header)(file.data + size_of(Bmp_File_Header))
	
	if file_header.header != Bmp_File_Header.EXPECTED_HEADER || file_header.file_size != file.count {
		return 0
	}
	
	if dib_header.bits_per_pixel != 32 || 
		dib_header.compression_method != .BI_BITFIELDS || 
		dib_header.alpha_mask != 0xFF000000 ||
		dib_header.red_mask   != 0x00FF0000 ||
		dib_header.green_mask != 0x0000FF00 ||
		dib_header.blue_mask  != 0x000000FF ||
		dib_header.height <= 0 {
		
		return 0
	}
	
	texture: u32
	
	glGenTextures(1, *texture)
	glBindTexture(GL_TEXTURE_2D, texture)
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, dib_header.width, dib_header.height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, file.data + file_header.offset_to_image)
	
	return texture
}

Rectangle :: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

rng: Random_State


gl_context: HGLRC

pack :: (x: s8, y: s8) -> s8 {
	return y * 8 + x
}

unpack :: (postion: s8) -> (s8, s8) {
	return postion & 7, postion >> 3
}

Move :: struct {
	piece_index: s8
	end: s8
}

using Piece :: enum_flags u8 {
	ROOK   :: 0x1
	BISHOP :: 0x2
	QUEEN  :: 0x3
	KING   :: 0x4
	KNIGHT :: 0x5
	PAWN   :: 0x6
	
	BLACK  :: 0x8
}

// @Volatile: Indices of king and rooks are hardocded below, an arbitrary board state cannot be used here
global_board := #run initialize_state(.[
	ROOK|BLACK, KNIGHT|BLACK, BISHOP|BLACK, QUEEN|BLACK, KING|BLACK, BISHOP|BLACK, KNIGHT|BLACK, ROOK|BLACK, 
	PAWN|BLACK, PAWN  |BLACK, PAWN  |BLACK, PAWN|BLACK , PAWN|BLACK, PAWN  |BLACK, PAWN  |BLACK, PAWN|BLACK, 
	0,          0,            0,            0,           0,          0,            0,            0         , 
	0,          0,            0,            0,           0,          0,            0,            0         , 
	0,          0,            0,            0,           0,          0,            0,            0         , 
	0,          0,            0,            0,           0,          0,            0,            0         , 
	PAWN,       PAWN,         PAWN,         PAWN,        PAWN,       PAWN,         PAWN,         PAWN      , 
	ROOK,       KNIGHT,       BISHOP,       QUEEN,       KING,       BISHOP,       KNIGHT,       ROOK      
])

BLACK_QUEENS_ROOK_INDEX :: 0
BLACK_KINGS_ROOK_INDEX  :: 7
BLACK_KING_INDEX        :: 4
WHITE_QUEENS_ROOK_INDEX :: 24
WHITE_KINGS_ROOK_INDEX  :: 31
WHITE_KING_INDEX        :: 28

pawn_square_bonus :: f32.[
	0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
	0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50,
	0.10, 0.10, 0.20, 0.30, 0.30, 0.20, 0.10, 0.10,
	0.05, 0.05, 0.10, 0.25, 0.25, 0.10, 0.05, 0.05,
	0.00, 0.00, 0.00, 0.20, 0.20, 0.00, 0.00, 0.00,
	0.05,-0.05,-0.10, 0.00, 0.00,-0.10,-0.05, 0.05,
	0.05, 0.10, 0.10,-0.20,-0.20, 0.10, 0.10, 0.05,
	0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00
]

knight_square_bonus :: f32.[
	-0.50,-0.40,-0.30,-0.30,-0.30,-0.30,-0.40,-0.50,
	-0.40,-0.20, 0.00, 0.00, 0.00, 0.00,-0.20,-0.40,
	-0.30, 0.00, 0.10, 0.15, 0.15, 0.10, 0.00,-0.30,
	-0.30, 0.05, 0.15, 0.20, 0.20, 0.15, 0.05,-0.30,
	-0.30, 0.00, 0.15, 0.20, 0.20, 0.15, 0.00,-0.30,
	-0.30, 0.05, 0.10, 0.15, 0.15, 0.10, 0.05,-0.30,
	-0.40,-0.20, 0.00, 0.05, 0.05, 0.00,-0.20,-0.40,
	-0.50,-0.40,-0.30,-0.30,-0.30,-0.30,-0.40,-0.50
]

bishop_square_bonus :: f32.[
	-0.20,-0.10,-0.10,-0.10,-0.10,-0.10,-0.10,-0.20,
	-0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.10,
	-0.10, 0.00, 0.05, 0.10, 0.10, 0.05, 0.00,-0.10,
	-0.10, 0.05, 0.05, 0.10, 0.10, 0.05, 0.05,-0.10,
	-0.10, 0.00, 0.10, 0.10, 0.10, 0.10, 0.00,-0.10,
	-0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10,-0.10,
	-0.10, 0.05, 0.00, 0.00, 0.00, 0.00, 0.05,-0.10,
	-0.20,-0.10,-0.10,-0.10,-0.10,-0.10,-0.10,-0.20
]

rook_square_bonus :: f32.[
	 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
	 0.05, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.05,
	-0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.05,
	-0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.05,
	-0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.05,
	-0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.05,
	-0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.05,
	 0.00, 0.00, 0.00, 0.05, 0.05, 0.00, 0.00, 0.00
]

queen_square_bonus :: f32.[
	-0.20,-0.10,-0.10,-0.05,-0.05,-0.10,-0.10,-0.20,
	-0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,-0.10,
	-0.10, 0.00, 0.05, 0.05, 0.05, 0.05, 0.00,-0.10,
	-0.05, 0.00, 0.05, 0.05, 0.05, 0.05, 0.00,-0.05,
	 0.00, 0.00, 0.05, 0.05, 0.05, 0.05, 0.00,-0.05,
	-0.10, 0.05, 0.05, 0.05, 0.05, 0.05, 0.00,-0.10,
	-0.10, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00,-0.10,
	-0.20,-0.10,-0.10,-0.05,-0.05,-0.10,-0.10,-0.20
]

king_square_bonus :: f32.[
	-0.30,-0.40,-0.40,-0.50,-0.50,-0.40,-0.40,-0.30,
	-0.30,-0.40,-0.40,-0.50,-0.50,-0.40,-0.40,-0.30,
	-0.30,-0.40,-0.40,-0.50,-0.50,-0.40,-0.40,-0.30,
	-0.30,-0.40,-0.40,-0.50,-0.50,-0.40,-0.40,-0.30,
	-0.20,-0.30,-0.30,-0.40,-0.40,-0.30,-0.30,-0.20,
	-0.10,-0.20,-0.20,-0.20,-0.20,-0.20,-0.20,-0.10,
	 0.20, 0.20, 0.00, 0.00, 0.00, 0.00, 0.20, 0.20,
	 0.20, 0.30, 0.10, 0.00, 0.00, 0.10, 0.30, 0.20
]

State :: struct {
	Castle :: enum_flags u8 {
		BLACK_NO_KINGSIDE
		BLACK_NO_QUEENSIDE
		WHITE_NO_KINGSIDE
		WHITE_NO_QUEENSIDE
	}	

	move_count: u16
	castle_state: Castle
	en_passant_position: s8 = -128
	board: [64]s8
	
	Piece_Info :: struct {
		piece: Piece
		location: s8
	}
	
	pieces: [32]Piece_Info
	white_pawn_mask: u64
	black_pawn_mask: u64
	player_color: Piece
}

create_mask :: (bits: [64]u64) -> u64 {
	mask: u64 = 0
	
	for bits {
		if it
			mask |= 1 << it_index
	}
	
	return mask
}

pawns_that_can_right_capture_mask :: #run create_mask(.[
	0, 0, 0, 0, 0, 0, 0, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	1, 1, 1, 1, 1, 1, 1, 0,  
	0, 0, 0, 0, 0, 0, 0, 0
])

pawns_that_can_left_capture_mask :: #run create_mask(.[
	0, 0, 0, 0, 0, 0, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1,  
	0, 0, 0, 0, 0, 0, 0, 0
])


	
file_mask :: #run create_mask(.[
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 0, 0
])

initialize_state :: (layout: [64]Piece) -> State {
	using state: State
	
	piece_index: s8 = 0
	
	for layout {
		if it == PAWN {
			white_pawn_mask |= 1 << it_index
		} else if it == PAWN|BLACK {
			black_pawn_mask |= 1 << it_index
		}
	
		if it {
			board[it_index] = piece_index
			pieces[piece_index].piece = it
			pieces[piece_index].location = cast() it_index
			
			piece_index += 1
		} else {
			board[it_index] = -1
		}
	}
	
	return state
}

add_move_if_legal :: (using state: State, moves: *[..]Move, using move: Move) {	
	check_checks :: (using state: State, using move: Move) -> bool {
		start := state.pieces[move.piece_index].location
		piece := state.pieces[move.piece_index].piece
		
		color := piece & BLACK
		
		if piece & ~BLACK == KING {
			distance := end - start
			
			if distance == -2 {
				if look_for_checks(state, start, color)      return true
				if look_for_checks(state, start - 1, color)  return true
			} else if distance == 2 {
				if look_for_checks(state, start, color)      return true
				if look_for_checks(state, start + 1, color)  return true				
			}
		}
	
		new_state := do_move(state, move)
		player_king := new_state.pieces[WHITE_KING_INDEX].location
		
		if color == BLACK  player_king = new_state.pieces[BLACK_KING_INDEX].location
		
		return look_for_checks(new_state, player_king, color)
	}

	if board[end] == -1 || (move.piece_index >= 16) != (board[end] >= 16) {
		if !check_checks(state, move) {
		
			array_add(moves, move)
		}
	}
}

add_capture_move_if_legal :: (using state: State, moves: *[..]Move, using move: Move) {	
	check_checks :: (using state: State, using move: Move) -> bool {
		color := state.pieces[move.piece_index].piece & BLACK
	
		new_state := do_move(state, move)
		player_king := new_state.pieces[WHITE_KING_INDEX].location
		
		if color == BLACK  player_king = new_state.pieces[BLACK_KING_INDEX].location
		
		return look_for_checks(new_state, player_king, color)
	}

	if board[end] != -1 && (move.piece_index >= 16) != (board[end] >= 16) {
		if !check_checks(state, move) {
		
			array_add(moves, move)
		}
	}
}

precompute_legal_knight_moves :: () -> [64][8]s8 {
	result: [64][8]s8
	
	for * result {
		moves := [..]s8.{data = it.data, count = 0, capacity = 8}
		
		x, y := unpack(cast() it_index)
		
		if x >= 1 && y >= 2  array_add(*moves, pack(x - 1, y - 2))
		if x >= 1 && y <= 5  array_add(*moves, pack(x - 1, y + 2))
		if x >= 2 && y >= 1  array_add(*moves, pack(x - 2, y - 1))
		if x >= 2 && y <= 6  array_add(*moves, pack(x - 2, y + 1))
		if x <= 6 && y >= 2  array_add(*moves, pack(x + 1, y - 2))
		if x <= 6 && y <= 5  array_add(*moves, pack(x + 1, y + 2))
		if x <= 5 && y >= 1  array_add(*moves, pack(x + 2, y - 1))
		if x <= 5 && y <= 6  array_add(*moves, pack(x + 2, y + 1))
		
		if moves.count != 8 {
			array_add(*moves, -1)
		}
	}
	
	return result
}

precompute_legal_king_moves :: () -> [64][8]s8 {
	result: [64][8]s8
	
	for * result {
		moves := [..]s8.{data = it.data, count = 0, capacity = 8}
		
		x, y := unpack(cast() it_index)
		
		if x >= 1            array_add(*moves, pack(x - 1, y    ))
		if x <= 6            array_add(*moves, pack(x + 1, y    ))
		if y >= 1            array_add(*moves, pack(x    , y - 1))
		if y <= 6            array_add(*moves, pack(x    , y + 1))
		if x >= 1 && y >= 1  array_add(*moves, pack(x - 1, y - 1))
		if x >= 1 && y <= 6  array_add(*moves, pack(x - 1, y + 1))
		if x <= 6 && y >= 1  array_add(*moves, pack(x + 1, y - 1))
		if x <= 6 && y <= 6  array_add(*moves, pack(x + 1, y + 1))
		
		if moves.count != 8 {
			array_add(*moves, -1)
		}
	}
	
	return result
}

Bishop_Move_Distance :: struct {
	up_left:    s8
	up_right:   s8
	down_left:  s8
	down_right: s8
}

precompute_bishop_move_distances :: () -> [64]Bishop_Move_Distance {
	result: [64]Bishop_Move_Distance
	
	for * result {
		x, y := unpack(cast() it_index)
		
		it.up_left    = min(    x,     y)
		it.up_right   = min(7 - x,     y)
		it.down_left  = min(    x, 7 - y)
		it.down_right = min(7 - x, 7 - y)
	}
	
	return result
}

legal_knight_moves :: #run precompute_legal_knight_moves()
legal_king_moves    :: #run precompute_legal_king_moves()
legal_bishop_moves  :: #run precompute_bishop_move_distances()

legal_king_moves_mask :: #run () -> [64]u64 {
	result: [64]u64
	
	for it, index: legal_king_moves {
		for it {
			if it != -1
		
			result[index] |= 1 << cast(u64) it
		}
	}
	
	return result
}()

MAX_DEPTH :: 255

repetition_hash: [MAX_DEPTH + 1]u64
legal_moves_list: [MAX_DEPTH + 1][..]Move
legal_quiesce_moves_list: [MAX_DEPTH + 1][..]Move
evaluation_list: [..]f32

moves_explored: u64

transposition_table: [1 << 26]struct {
	hash: u64
	value: f32
	kind: enum u8 {
		LOWER_BOUND
		UPPER_BOUND
		EXACT
	}
	depth: s8
	move: Move
}

evaluate_black :: (using state: State, using piece: State.Piece_Info) -> f32 {
	if location == -1 return 0
	
	value: f32
	
	if piece & ~BLACK == {
		case PAWN   value = 1.0 + pawn_square_bonus  [63 - location]
		case BISHOP value = 3.3 + bishop_square_bonus[63 - location]
		case KNIGHT value = 3.2 + knight_square_bonus[63 - location]
		case ROOK   
			value = 5.0 + rook_square_bonus  [63 - location]
			// Apply a bonus for rooks on open and semi-open files
			mask := file_mask << cast()(location & 7)
			if !(white_pawn_mask & mask) {
				value += 0.3
			}
			if !(black_pawn_mask & mask) {
				value += 0.3
			}
		case QUEEN  value = 9.0 + queen_square_bonus [63 - location]
		case KING   value = 0.0 + king_square_bonus  [63 - location]
	}
	
	return value
}

evaluate_white :: (using state: State, using piece: State.Piece_Info) -> f32 {
	if location == -1 return 0
	
	value: f32
	
	if piece & ~BLACK == {
		case PAWN   value = 1.0 + pawn_square_bonus  [location]
		case BISHOP value = 3.3 + bishop_square_bonus[location]
		case KNIGHT value = 3.2 + knight_square_bonus[location]
		case ROOK   
			value = 5.0 + rook_square_bonus[location]
			// Apply a bonus for rooks on open and semi-open files
			mask := file_mask << cast()(location & 7)
			if !(white_pawn_mask & mask) {
				value += 0.3
			}
			if !(black_pawn_mask & mask) {
				value += 0.3
			}
		case QUEEN  value = 9.0 + queen_square_bonus [location]
		case KING   value = 0.0 + king_square_bonus  [location]
	}
	
	return value
}
	
order_moves :: (using state: State, moves: []Move, old_best: Move, depth: s8 = 0, alpha: f32 = -1e9, beta: f32 = 1e9) {
	if evaluation_list.capacity < moves.count {
		evaluation_list.data = reallocate(evaluation_list.data, size_of(f32) * moves.count)
		evaluation_list.capacity = moves.count
	}
	
	evaluation_list.count = moves.count
	
	for moves {
		if it.piece_index == old_best.piece_index && it.end == old_best.end {
			evaluation_list[it_index] = 10000
		}
		else if board[it.end] != -1 {
			if player_color == BLACK evaluation_list[it_index] = evaluate_white(state, pieces[board[it.end]]) - evaluate_black(state, pieces[it.piece_index])
			else                     evaluation_list[it_index] = evaluate_black(state, pieces[board[it.end]]) - evaluate_white(state, pieces[it.piece_index])
		} else if depth > 5 {
			new_state := do_move(state, it)
			evaluation_list[it_index] = -quiesce(new_state, -beta, -alpha) - 100 // offset so captures will always be ahead
		} else {
		
			evaluation_list[it_index] = -10000
		}
	}

	for moves {
		i := it_index
		
		if evaluation_list[i] <= -10000
			continue;
		
		while i > 0 {
			a := evaluation_list[i - 1]
			b := evaluation_list[i]
		
			if a > b
				break;
			
			evaluation_list[i] = a
			evaluation_list[i - 1] = b
			
			moves[i] = moves[i - 1]
			moves[i - 1] = it
			
			i -= 1
		}
	}
}

evaluate_position :: (using state: State) -> f32 {
	if check_for_drawn_endgame(state)
		return 0

	evaluation: f32 = 0
	
	left_black_pawns: u64
	left_white_pawns: u64
	middle_black_pawns: u64
	middle_white_pawns: u64
	
	mask := file_mask
	
	for 8 {
		black_pawns := black_pawn_mask & mask
		white_pawns := white_pawn_mask & mask
		
		// Bonus for passed pawns
		if black_pawns && !white_pawns {
			evaluation += 0.2
		} else if white_pawns && !black_pawns {
			evaluation -= 0.2
		}
		
		// Penalty for doubled pawns (currently no extra penalty for tripled or more so we can avoid a loop)
		if black_pawns & (black_pawns - 1) {
			evaluation -= 0.1
		}
		if white_pawns & (white_pawns - 1) {
			evaluation += 0.1
		}
		
		// Penalty for isolated pawns
		if !left_black_pawns && middle_black_pawns && !black_pawns {
			evaluation -= 0.1
		}
		if !left_white_pawns && middle_white_pawns && !white_pawns {
			evaluation += 0.1
		}
		
		left_black_pawns = middle_black_pawns
		left_white_pawns = middle_white_pawns
		middle_black_pawns = black_pawns
		middle_white_pawns = white_pawns
		
		mask <<= 1
	}
	
	// Still need to check for isolated pawns on the h file
	if !left_black_pawns && middle_black_pawns {
		evaluation -= 0.3
	}
	if !left_white_pawns && middle_white_pawns {
		evaluation += 0.3
	}

	for 0..16 {		
		evaluation += evaluate_black(state, pieces[it])
	}
	
	for 16..32 {
		evaluation -= evaluate_white(state, pieces[it])
	}
	
	if player_color != BLACK return -evaluation
	else return evaluation
}

MAX_MOVES :: 400_000

quiesce :: (using state: State, alpha: f32, beta: f32, depth := 0) -> f32 {
	if moves_explored == MAX_MOVES  return 0
	
	key := hash(state)
	
	entry := *transposition_table[key & (transposition_table.count - 1)]
	
	current_alpha := alpha
	current_beta  := beta
	
	if entry.hash == key && entry.depth >= 0 {
		stats.transpositions_matched += 1
	
		if entry.kind == .EXACT {
			return entry.value
		} else if entry.kind == .LOWER_BOUND {
			current_alpha = max(entry.value, current_alpha)
		} else if entry.kind == .UPPER_BOUND {
			current_beta = min(current_beta, entry.value)
		}
		
		if current_alpha >= current_beta {
			stats.beta_cutoffs += 1
			return entry.value
		}
	}
	
	moves_explored += 1
	stand_pat := evaluate_position(state)
	
	if stand_pat >= beta {
		stats.beta_cutoffs += 1
		return beta
	} if current_alpha < stand_pat
		current_alpha = stand_pat
	
	
	legal_moves := *legal_quiesce_moves_list[depth]
	legal_moves.count = 0
	
	if player_color == BLACK {
		for 0..16 {
			if pieces[it].location != -1 get_capture_moves_for_piece(state, legal_moves, cast() it)		
		}
	} else {
		for 16..32 {
			if pieces[it].location != -1 get_capture_moves_for_piece(state, legal_moves, cast() it)		
		}
	}
	
	best_move: Move
	
	
	for <<legal_moves {
		new_state := do_move(state, it)
		
		value := -quiesce(new_state, -beta, -current_alpha, depth + 1)
	
		if value > current_alpha {
			best_move = it
			current_alpha = value
		}
	
		if current_alpha >= beta {
			stats.beta_cutoffs += 1
			return beta
		}
	}

	return current_alpha
}

repetition_table: [1024]u64

check_for_repetition :: (key_: u64) -> (repeated: bool, index: u64) {
	key := key_
	if key < 1 key = 1

	slot := key & (repetition_table.count - 1)
	
	while repetition_table[slot] {
		if repetition_table[slot] == key {
			return true, slot
		}
		
		slot += 1
		slot &= repetition_table.count - 1
	}
	
	
	repetition_table[slot] = key
	return false, slot
}

remove_repetition :: (slot: u64) {
	
	repetition_table[slot] = 0
	
	i := slot
	
	j := i
	
	while true {
		j += 1
		j &= repetition_table.count - 1
		
		if !repetition_table[j]
			break;
	
		key := repetition_table[j]
		key &= repetition_table.count - 1
	
		if i <= j {
			if i < key && key <= j
				continue
		} else {
			if i < key || key <= j
				continue
		}
		
		repetition_table[i] = repetition_table[j]
		i = j
	}
}

check_for_drawn_endgame :: (using state: State) -> bool {	
	value: f32
	
	bishops := 0
	knights := 0
	
	for 0..16 {
		using _ := pieces[it]
	
		if location == -1 continue;
	
		if piece & ~BLACK == {
			case PAWN   return false
			case BISHOP bishops += 1
			case KNIGHT knights += 1
			case ROOK   return false
			case QUEEN  return false
		}
	}
	
	if !((bishops <= 1 && knights == 0) || (knights <= 2 && bishops == 0)) {
		return false
	}
	
	bishops = 0
	knights = 0
	
	for 16..32 {
		using _ := pieces[it]
		if location == -1 continue;
		
		if piece & ~BLACK == {
			case PAWN   return false
			case BISHOP bishops += 1
			case KNIGHT knights += 1
			case ROOK   return false
			case QUEEN  return false
		}
	}
	
	return (bishops <= 1 && knights == 0) || (knights <= 2 && bishops == 0)
}

stats: struct {
	beta_cutoffs: u64
	transpositions_matched: u64
}

minimax :: (using state: State, depth: s8, alpha: f32 = -1e9, beta: f32 = 1e9) -> (f32, Move) {
	if moves_explored == MAX_MOVES  return 0, .{}
	
	alpha_orig := alpha
	
	key := hash(state)
	
	entry := *transposition_table[key & (transposition_table.count - 1)]
	
	current_beta  := beta
	if entry.hash == key && entry.depth >= depth {
		stats.transpositions_matched += 1
	
		if entry.kind == .EXACT {
			return entry.value, entry.move
		} else if entry.kind == .LOWER_BOUND {
			alpha_orig = max(entry.value, alpha_orig)
		} else if entry.kind == .UPPER_BOUND {
			current_beta = min(current_beta, entry.value)
		}
		
		if alpha_orig >= current_beta {
			stats.beta_cutoffs += 1
			return entry.value, entry.move
		}
	}
	
	current_alpha := alpha_orig
	
	best_move_value: f32 = -1e9
	best_move := Move.{-1}
	
	defer {
		if depth >= entry.depth {
			entry.value = best_move_value
			entry.hash = key
			entry.depth = depth
			entry.move = best_move
			
			if best_move_value <= alpha_orig
				entry.kind = .UPPER_BOUND
			else if best_move_value >= current_beta
				entry.kind = .LOWER_BOUND
			else
				entry.kind = .EXACT
		}
	}

	legal_moves := *legal_moves_list[depth]
	legal_moves.count = 0
	
	if player_color == BLACK {
		for 0..16 {
			if pieces[it].location != -1 get_moves_for_piece(state, legal_moves, cast() it)		
		}
	} else {
		for 16..32 {
			if pieces[it].location != -1 get_moves_for_piece(state, legal_moves, cast() it)		
		}
	}
	
	if !legal_moves.count {
		player_king := pieces[WHITE_KING_INDEX].location
		
		if player_color == BLACK player_king = pieces[BLACK_KING_INDEX].location
	
		if look_for_checks(state, player_king, player_color) {
			best_move_value = -(1e3 - 0.001 * cast(f32) move_count)
			return best_move_value, best_move
		} else {
			best_move_value = 0
			return best_move_value, best_move
		}
	}
	
	repeated, repetition_stored := check_for_repetition(key)
	defer if !repeated remove_repetition(repetition_stored)
	
	if repeated {
		best_move_value = 0
		return best_move_value, best_move
	}
	
	if depth == 0 {		
		best_move_value = quiesce(state, alpha, beta)
		
		return best_move_value, best_move
	}
	
	if depth >= 1
		order_moves(state, <<legal_moves, entry.move, depth, current_alpha, current_beta)
	
	for <<legal_moves {
		new_state := do_move(state, it)
		
		value := -minimax(new_state, depth - 1, -current_beta, -current_alpha)

		if value > best_move_value {
			best_move_value = value
			
			best_move = it
		}
		
		current_alpha = max(value, current_alpha)
	
		if current_alpha >= current_beta {
			stats.beta_cutoffs += 1
			break
		}
	}
	
	return best_move_value, best_move
	
}

get_piece :: (using state: State, index: s8) -> Piece {
	if board[index] == -1 return 0
	else return pieces[board[index]].piece
}

print_mask :: (mask: u64) {
	current_mask := mask

	for 8 {
		for 8 {
			print("%", current_mask & 1)
			current_mask >>= 1
		}
		
		print("\n")
	}
}

look_for_checks :: (using state: State, king_position: s8, king_color: Piece) -> bool {
	enemy_color := king_color ^ BLACK
	
	if king_color == BLACK {		
		if ((white_pawn_mask & pawns_that_can_right_capture_mask) >> 7 | 
		    (white_pawn_mask & pawns_that_can_left_capture_mask) >> 9) & 
			(1 << cast(u64) king_position) return true
			
		if legal_king_moves_mask[pieces[WHITE_KING_INDEX].location] & 1 << cast(u64) king_position return true
	} else {
		if ((black_pawn_mask & pawns_that_can_left_capture_mask) << 7 | 
		    (black_pawn_mask & pawns_that_can_right_capture_mask) << 9) & 
			(1 << cast(u64) king_position) return true
		
		if legal_king_moves_mask[pieces[BLACK_KING_INDEX].location] & 1 << cast(u64) king_position return true
	}

	for legal_knight_moves[king_position] {
		if it == -1  break;
		
		if get_piece(state, it) == KNIGHT|enemy_color {
			return true
		}
	}
	
	/*
	for legal_king_moves[king_position] {
		if it == -1  break;
		
		if get_piece(state, it) == KING|enemy_color {
			return true
		}
	}
	*/
	
	
	look_for_line_checks :: (using state: State, king_position: s8, king_color: Piece, num_moves: s8, delta: s8, piece_kind: Piece) -> bool {
		move := king_position
		
		for num_moves {
			move += delta
			
			piece := get_piece(state, move)
				
			if piece {
				
				if piece & BLACK == king_color {
					return false
				} else {
					kind := piece & ~BLACK
					return kind == piece_kind || kind == QUEEN
				}
			}
		}
		
		return false
	}
	
	if look_for_line_checks(state, king_position, king_color, legal_bishop_moves[king_position].up_left,   -9, BISHOP)  return true
	if look_for_line_checks(state, king_position, king_color, legal_bishop_moves[king_position].up_right,  -7, BISHOP)  return true
	if look_for_line_checks(state, king_position, king_color, legal_bishop_moves[king_position].down_left,  7, BISHOP)  return true
	if look_for_line_checks(state, king_position, king_color, legal_bishop_moves[king_position].down_right, 9, BISHOP)  return true
	
	x, y := unpack(king_position)
	
	if look_for_line_checks(state, king_position, king_color,     y, -8, ROOK)  return true
	if look_for_line_checks(state, king_position, king_color,     x, -1, ROOK)  return true
	if look_for_line_checks(state, king_position, king_color, 7 - y,  8, ROOK)  return true
	if look_for_line_checks(state, king_position, king_color, 7 - x,  1, ROOK)  return true

	
	return false
}

get_moves_for_piece :: (using state: State, moves: *[..]Move, piece_index: s8) {
	position := pieces[piece_index].location
	piece := pieces[piece_index].piece
	
	color := piece & BLACK
	piece_kind := piece & ~BLACK
	
	x, y := unpack(position)
		
	add_line_moves :: (using state: State, moves: *[..]Move, piece_index: s8, num_moves: s8, delta: s8) {
		move := pieces[piece_index].location
		
		for num_moves {
			move += delta
			
			add_move_if_legal(state, moves, .{piece_index, move})
			
			if board[move] != -1
				break
		}
	}
	
	if piece == PAWN {
		if board[position - 8] == -1 {
			if y == 6 && board[position - 16] == -1 {
				add_move_if_legal(state, moves, .{piece_index, position - 16})
			}
			
			add_move_if_legal(state, moves, .{piece_index, position - 8})
		}
		
		if x < 7 && board[position - 7] != -1  add_move_if_legal(state, moves, .{piece_index, position - 7})
		if x > 0 && board[position - 9] != -1  add_move_if_legal(state, moves, .{piece_index, position - 9})
		
		
		if position - 7 == en_passant_position || position - 9 == en_passant_position {
			add_move_if_legal(state, moves, .{piece_index, en_passant_position})
		}
	} else if piece == PAWN|BLACK {
		if board[position + 8] == -1 {
			if y == 1 && board[position + 16] == -1 {
				add_move_if_legal(state, moves, .{piece_index, position + 16})
			}
			
			add_move_if_legal(state, moves, .{piece_index, position + 8})
		}
		
		if x < 7 && board[position + 9] != -1  add_move_if_legal(state, moves, .{piece_index, position + 9})
		if x > 0 && board[position + 7] != -1  add_move_if_legal(state, moves, .{piece_index, position + 7})
		
		
		if position + 7 == en_passant_position || position + 9 == en_passant_position {
			add_move_if_legal(state, moves, .{piece_index, en_passant_position})
		}
	} else if piece_kind == KNIGHT {
		for legal_knight_moves[position] {
			if it == -1  break;
			
			add_move_if_legal(state, moves, .{piece_index, it})
		}
	} else if piece_kind == KING {
		for legal_king_moves[position] {
			if it == -1  break;
			
			add_move_if_legal(state, moves, .{piece_index, it})
		}
		
		if (color == BLACK && !(castle_state & .BLACK_NO_KINGSIDE)) || (color != BLACK && !(castle_state & .WHITE_NO_KINGSIDE)) {
			if board[position + 1] == -1 && board[position + 2] == -1 {
			add_move_if_legal(state, moves, .{piece_index, position + 2})
			}
		}
		
		if (color == BLACK && !(castle_state & .BLACK_NO_QUEENSIDE)) || (color != BLACK && !(castle_state & .WHITE_NO_QUEENSIDE)) {
			if board[position - 1] == -1 && board[position - 2] == -1 && board[position - 3] == -1 {
			add_move_if_legal(state, moves, .{piece_index, position - 2})
			}
		}
	} else if piece_kind == BISHOP {
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_left,   -9)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_right,  -7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_left,  7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_right, 9)
	} else if piece_kind == ROOK {
		x, y := unpack(position)
	
		add_line_moves(state, moves, piece_index,     y, -8)
		add_line_moves(state, moves, piece_index,     x, -1)
		add_line_moves(state, moves, piece_index, 7 - y,  8)
		add_line_moves(state, moves, piece_index, 7 - x,  1)
	} else if piece_kind == QUEEN {
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_left,   -9)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_right,  -7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_left,  7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_right, 9)
		
		x, y := unpack(position)
	
		add_line_moves(state, moves, piece_index,     y, -8)
		add_line_moves(state, moves, piece_index,     x, -1)
		add_line_moves(state, moves, piece_index, 7 - y,  8)
		add_line_moves(state, moves, piece_index, 7 - x,  1)
	}
}

get_capture_moves_for_piece :: (using state: State, moves: *[..]Move, piece_index: s8) {
	position := pieces[piece_index].location
	piece := pieces[piece_index].piece
	
	color := piece & BLACK
	piece_kind := piece & ~BLACK
	
	x, y := unpack(position)
		
	add_line_moves :: (using state: State, moves: *[..]Move, piece_index: s8, num_moves: s8, delta: s8) {
		move := pieces[piece_index].location
		
		for num_moves {
			move += delta
			
			add_capture_move_if_legal(state, moves, .{piece_index, move})
			
			if board[move] != -1
				break
		}
	}
	
	if piece == PAWN {		
		if x < 7  add_capture_move_if_legal(state, moves, .{piece_index, position - 7})
		if x > 0  add_capture_move_if_legal(state, moves, .{piece_index, position - 9})
		
		
		if position - 7 == en_passant_position || position - 9 == en_passant_position {
			add_move_if_legal(state, moves, .{piece_index, en_passant_position})
		}
	} else if piece == PAWN|BLACK {
		if x < 7  add_capture_move_if_legal(state, moves, .{piece_index, position + 9})
		if x > 0  add_capture_move_if_legal(state, moves, .{piece_index, position + 7})
		
		
		if position + 7 == en_passant_position || position + 9 == en_passant_position {
			add_move_if_legal(state, moves, .{piece_index, en_passant_position})
		}
	} else if piece_kind == KNIGHT {
		for legal_knight_moves[position] {
			if it == -1  break;
			
			add_capture_move_if_legal(state, moves, .{piece_index, it})
		}
	} else if piece_kind == KING {
		for legal_king_moves[position] {
			if it == -1  break;
			
			add_capture_move_if_legal(state, moves, .{piece_index, it})
		}
	} else if piece_kind == BISHOP {
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_left,   -9)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_right,  -7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_left,  7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_right, 9)
	} else if piece_kind == ROOK {
		x, y := unpack(position)
	
		add_line_moves(state, moves, piece_index,     y, -8)
		add_line_moves(state, moves, piece_index,     x, -1)
		add_line_moves(state, moves, piece_index, 7 - y,  8)
		add_line_moves(state, moves, piece_index, 7 - x,  1)
	} else if piece_kind == QUEEN {
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_left,   -9)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].up_right,  -7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_left,  7)
		add_line_moves(state, moves, piece_index, legal_bishop_moves[position].down_right, 9)
		
		x, y := unpack(position)
	
		add_line_moves(state, moves, piece_index,     y, -8)
		add_line_moves(state, moves, piece_index,     x, -1)
		add_line_moves(state, moves, piece_index, 7 - y,  8)
		add_line_moves(state, moves, piece_index, 7 - x,  1)
	}
}


selected_square: s8 = -1
undo_last_move := false

do_move :: (state: State, using move: Move) -> State {
	using new_state := state

	piece_info := *pieces[piece_index]
	
	start := piece_info.location
	piece_info.location = end
	piece := piece_info.piece
	
	if board[end] != -1 {
		pieces[board[end]].location = -1
	}
	
	white_pawn_mask &= ~(1 << cast(u64) start | 1 << cast(u64) end)
	black_pawn_mask &= ~(1 << cast(u64) start | 1 << cast(u64) end)
	
	distance := end - start
	
	if piece & ~BLACK == KING {	
		if distance == 2 {
			rook: s8 = WHITE_KINGS_ROOK_INDEX
			
			if piece & BLACK {
				rook = BLACK_KINGS_ROOK_INDEX	
			}
			
			pieces[rook].location = end - 1
		
			board[end - 1] = rook
			board[end + 1] = -1
		} else if distance == -2 {
			rook: s8 = WHITE_QUEENS_ROOK_INDEX
			
			if piece & BLACK {
				rook = BLACK_QUEENS_ROOK_INDEX	
			}
			
			pieces[rook].location = end + 1
		
			board[end + 1] = rook
			board[end - 2] = -1
		}
	}

	board[end] = piece_index
	board[start] = -1
	
	old_en_passant_position := en_passant_position
	en_passant_position = -128
	
	if piece == PAWN {
		white_pawn_mask |= (1 << cast(u64) end)
	
		if end == old_en_passant_position {
			pieces[board[end + 8]].location = -1
			board[end + 8] = -1
			
			black_pawn_mask &= ~(1 << cast(u64) (end + 8))
		} else if distance == -16 {
			en_passant_position = start - 8
		} else if end < 8 {
			piece_info.piece = QUEEN
			white_pawn_mask &= ~(1 << cast(u64) end)
		}
	} else if piece == PAWN|BLACK {	
		black_pawn_mask |= (1 << cast(u64) end)	
		
		if end == old_en_passant_position {
			pieces[board[end - 8]].location = -1
			board[end - 8] = -1
			
			white_pawn_mask &= ~(1 << cast(u64) (end - 8))
		} else if distance == 16 {
			en_passant_position = start + 8
		} else if end >= 56 {
			piece_info.piece = QUEEN|BLACK
			black_pawn_mask &= ~(1 << cast(u64) end)
		}
	}
	
	if piece == KING {
		castle_state |= .WHITE_NO_KINGSIDE
		castle_state |= .WHITE_NO_QUEENSIDE
	} else if piece == KING|BLACK {
		castle_state |= .BLACK_NO_KINGSIDE
		castle_state |= .BLACK_NO_QUEENSIDE
	}
	
	if start == 0 || end == 0 {
		castle_state |= .BLACK_NO_QUEENSIDE
	} else if start == 7 || end == 7 {
		castle_state |= .BLACK_NO_KINGSIDE
	}
	
	if start == 56 || end == 56 {
		castle_state |= .WHITE_NO_QUEENSIDE
	} else if start == 63 || end == 63 {
		castle_state |= .WHITE_NO_KINGSIDE
	}
	
	player_color ^= BLACK
	move_count += 1
	
	return new_state
}

move_history: [..]Move
black_difficulty: u64
white_difficulty: u64

Hashing_Data :: struct {
	piece_positions: [16][65]u64
	castle_state: [16]u64
	en_passant_file: [8]u64
	black_move: u64
}

hash ::  (using state: State) -> u64 {
	hash: u64 = 0
	
	for pieces {
		hash ^= hashing_data.piece_positions[cast(u8) it.piece][it.location + 1]
	}
	
	hash ^= hashing_data.castle_state[cast(u8) castle_state]
	
	if en_passant_position >= 0
		hash ^= hashing_data.en_passant_file[en_passant_position & 7]
	
	if player_color
		hash ^= hashing_data.black_move
	
	return hash
}

precompute_hashing_data :: () -> Hashing_Data {
	rng := create_random(10, 20)
	
	using data: Hashing_Data
	
	for * piece_positions {
		for * <<it {
			<<it = random_u64(*rng)
		} 
	}
	
	for * castle_state {
		<<it = random_u64(*rng)
	}
	
	for * en_passant_file {
		<<it = random_u64(*rng)
	}
	
	black_move = random_u64(*rng)
	
	return data
}

hashing_data :: #run precompute_hashing_data()

undo_list: [..]State

select_ai_move :: () -> Move {
	stats = .{}
	moves_explored = 0
	
	depth := get_player_difficulty()
	
	value, ai_move := minimax(global_board, cast() depth)
	
	total_explored := moves_explored
	
	
	while outer: moves_explored < MAX_MOVES {							
		if depth == MAX_DEPTH  break;
	
		moves_explored = 0
		
		low_delta: f32 = 0.25
		high_delta: f32 = 0.25
		
		while true {
			alpha := value - low_delta
			beta := value + high_delta
			
			new_value, new_move := minimax(global_board, cast() depth, alpha, beta)
			
			if new_move.piece_index == -1 break outer
			
			print("Move: %\n", new_move)
		
			if moves_explored >= MAX_MOVES  break outer
			
			if new_value <= alpha {
				print("Alpha fail\n")
				low_delta *= 2
			} else if new_value >= beta {
				print("Beta fail\n")
				high_delta *= 2
			} else {
				value = new_value
				ai_move = new_move
				break
			}
		}

		total_explored += moves_explored
		
		if value <= -900 || value >= 900 {
			break;
		}
		depth += 1
	}
	
	print("%\n", ai_move)
	print("%\n", stats)
	print("% moves explored at depth %\n", total_explored, depth)
	print("move valued at %\n", value)
	
	return ai_move
}

draw :: (moves: []Move) {
	glViewport(0, 0, window_width, window_height)
	glClear(GL_COLOR_BUFFER_BIT)
	
	glMatrixMode(GL_PROJECTION)
	glLoadIdentity()
	glOrtho(0, 8, 8, 0, -5, 5)
	glMatrixMode(GL_MODELVIEW)
	glLoadIdentity()
	
	glDisable(GL_TEXTURE_2D)
	glBegin(GL_QUADS)
	
	for y: 8 {
		for x: 8 {
			if x + y & 1
				glColor3f(0.4, 0.3, 0.2)
			else
				glColor3f(0.8, 0.7, 0.5)
			
			
			glVertex2f(cast(f32) x, cast(f32) y)
			glVertex2f(cast(f32) x + 1, cast(f32) y)
			glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
			glVertex2f(cast(f32) x, cast(f32) y + 1)
		}
	}
	
	if selected_square != -1 {
		x, y := unpack(selected_square)
		
		if white_difficulty && !black_difficulty  {
			x = 7 - x
			y = 7 - y
		}
		
		glColor4f(1, 1, 0, 0.4)
		
		glVertex2f(cast(f32) x, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
		glVertex2f(cast(f32) x, cast(f32) y + 1)
	}
	
	if move_history {
		move := array_peek(move_history)
		
		start := undo_list[undo_list.count - 1].pieces[move.piece_index].location
		
		glColor4f(0, 0, 1, 0.4)
		
		x, y := unpack(start)
	
		if white_difficulty && !black_difficulty  {
			x = 7 - x
			y = 7 - y
		}
		
		glVertex2f(cast(f32) x, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
		glVertex2f(cast(f32) x, cast(f32) y + 1)
		
		x, y = unpack(move.end)
		
		if white_difficulty && !black_difficulty  {
			x = 7 - x
			y = 7 - y
		}
		
		glVertex2f(cast(f32) x, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
		glVertex2f(cast(f32) x, cast(f32) y + 1)
	}
	
	glColor4f(0, 1, 0, 0.4)
	
	for moves {
		x, y := unpack(it.end)
		
		if white_difficulty && !black_difficulty  {
			x = 7 - x
			y = 7 - y
		}
		
		glVertex2f(cast(f32) x, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y)
		glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
		glVertex2f(cast(f32) x, cast(f32) y + 1)
	}
	
	glEnd()
	
	glColor3f(1, 1, 1)
	
	glEnable(GL_TEXTURE_2D)
	glBegin(GL_QUADS)
	
	for global_board.pieces {
		piece := it.piece
		
		if piece {
			x, y := unpack(it.location)
			
			if white_difficulty && !black_difficulty  {
				x = 7 - x
				y = 7 - y
			}
			
			y_coord: f32 = 0.5
			x_coord: f32 = 0
			
			if piece & BLACK {
				y_coord = 0
			}
			
			kind := piece & ~BLACK
			
			if kind == {
				case QUEEN
					x_coord = 1.0 / 6.0
				case BISHOP 
					x_coord = 2.0 / 6.0
				case KNIGHT
					x_coord = 3.0 / 6.0
				case ROOK
					x_coord = 4.0 / 6.0
				case PAWN
					x_coord = 5.0 / 6.0
			}
			
			
			glTexCoord2f(x_coord, y_coord + 0.5)
			glVertex2f(cast(f32) x, cast(f32) y)
			
			glTexCoord2f(x_coord + 1.0 / 6.0, y_coord + 0.5)
			glVertex2f(cast(f32) x + 1, cast(f32) y)
			
			glTexCoord2f(x_coord + 1.0 / 6.0, y_coord)
			glVertex2f(cast(f32) x + 1, cast(f32) y + 1)
			
			glTexCoord2f(x_coord, y_coord)
			glVertex2f(cast(f32) x, cast(f32) y + 1)
		}
	}
	
	glEnd()
}

get_player_difficulty :: () -> u64 {
	if global_board.player_color == BLACK {
		return black_difficulty
	}
	
	return white_difficulty
}

undo_move :: () {
	if undo_list.count {
		global_board = array_pop(*undo_list)
		array_pop(*move_history)
		
		repeated, repetition_stored := check_for_repetition(hash(global_board));
		remove_repetition(repetition_stored)
	}
}

make_move :: (move: Move) {
	array_add(*undo_list, global_board)
	
	if check_for_repetition(hash(global_board)) {
		game_over = true
		print("Repetition!\n")
	}

	global_board = do_move(global_board, move)
	array_add(*move_history, move)
}

game_over: bool

ai_start_semaphore: HANDLE
ai_stop_semaphore:  HANDLE

ai_thread_proc :: (userdata: *void) -> u32 #c_call {
	ai_move := cast(*Move) userdata
	while true {
		WaitForSingleObject(ai_start_semaphore);
		
		<<ai_move = select_ai_move()
		
		ReleaseSemaphore(ai_stop_semaphore)
	}
	
	return 0
}

main :: () {
	defer exit(0)
	
	ai_start_semaphore = CreateSemaphoreA(lMaximumCount = 1)
	ai_stop_semaphore  = CreateSemaphoreA(lMaximumCount = 1)
	
	ai_move: Move
	
	ai_thread := create_thread(ai_thread_proc, *ai_move)

	arguments := get_command_line_arguments()
	
	if arguments.count >= 2 {
		remaining: string
		black_difficulty, remaining = read_u64(arguments[1])
		
		if remaining {
			print("Invalid difficulty level %\n", arguments[1])
			return
		}
	}
	
	if arguments.count >= 3 {
		remaining: string
		white_difficulty, remaining = read_u64(arguments[2])
		
		if remaining {
			print("Invalid difficulty level %\n", arguments[2])
			return
		}
	}
	
	rand_seed: s64
	
	QueryPerformanceCounter(*rand_seed)

	rng = create_random(cast(u64) rand_seed, GetTickCount())
	
	performance_counter_frequency: s64
	
	QueryPerformanceFrequency(*performance_counter_frequency)
	
	counter_scale := 1.0 / cast(f32) performance_counter_frequency
	
	startup_info: STARTUPINFOW
	
	GetStartupInfoW(*startup_info)
	
	show_command : = SW_SHOWDEFAULT
	if startup_info.dwFlags & STARTF_USESHOWWINDOW {
		show_command = cast() startup_info.wShowWindow
	}
	
	instance := GetModuleHandleW(null)
	
	class_name := to_windows_string("Window Class")
	window_class: WNDCLASSW
	
	window_class.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW
	window_class.lpfnWndProc = (hwnd: HWND, uMsg: MSG.Message, wParam: u64, lParam: s64) -> s64 #c_call {	
		if uMsg == {
			case WM_CLOSE

				DestroyWindow(hwnd)
				
				print("Closing\n")
				
			case WM_DESTROY
				glFinish()
				
				dc := wglGetCurrentDC()
				
				if !wglDeleteContext(gl_context)
					print("Failed to delete gl context\n")
					
				if !ReleaseDC(hwnd, dc)
					print("Failed to delete device context\n")
				
				PostQuitMessage(0)
				
			case WM_PAINT
				paint: PAINTSTRUCT = --
				
				dc := BeginPaint(hwnd, *paint)
				EndPaint(hwnd, *paint)
				
			case WM_SIZE
				client_rect: RECT = --
				
				GetClientRect(hwnd, *client_rect)
				
				window_width = client_rect.right - client_rect.left
				window_height = client_rect.bottom - client_rect.top
				
				print("%x%\n", window_width, window_height)
				print("----------\n")
				
			case WM_LBUTTONDOWN
				
				x := cast(s16) lParam
				y := cast(s16) (lParam >> 16)
				
				x /= 100
				y /= 100
				
				if white_difficulty && !black_difficulty {
					x = 7 - x
					y = 7 - y
				}
				
				square := pack(cast() x, cast() y)
				
				if square == selected_square
					selected_square = -1
				else
					selected_square = square
					
			case WM_RBUTTONDOWN
				
				undo_last_move = true
				
			else
				return DefWindowProcW(hwnd, uMsg, wParam, lParam)
		}
		
		return 0
	}
	window_class.hInstance = instance
	window_class.lpszClassName = class_name
	window_class.hbrBackground = GetStockObject(BLACK_BRUSH)
	
	
	if RegisterClassW(*window_class) == 0 {
		print("Failed to register window class\n")
		print("%\n", GetLastError())
		return
	}
	
	
	window_style := WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX
	
	window_rect: RECT
	
	window_rect.top = 0
	window_rect.bottom = window_height
	window_rect.left = 0
	window_rect.right = window_width
	
	AdjustWindowRectEx(*window_rect, window_style ^ WS_OVERLAPPED | WS_TILED)
	
	window_handle := CreateWindowExW(lpClassName = class_name, lpWindowName = to_windows_string("Test Window"), dwStyle = window_style, 
		nWidth = window_rect.right - window_rect.left, nHeight = window_rect.bottom - window_rect.top, hInstance = instance)
	
	if window_handle == null {
		print("Failed to open window\n")
		print("%\n", GetLastError())
		return
	}
	
	device_context := GetDC(window_handle)
	
	desired_format: PIXELFORMATDESCRIPTOR
	desired_format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER
	desired_format.cColorBits = 32
	desired_format.cAlphaBits = 8
	desired_format.iLayerType = PFD_MAIN_PLANE
	
	found_format := ChoosePixelFormat(device_context, *desired_format)
	
	if found_format == 0 {
		print("Could not find a pixel format\n")
		return
	}
	
	used_format: PIXELFORMATDESCRIPTOR
	
	if !SetPixelFormat(device_context, found_format, *used_format) {
		print("Failed to set pixel format")
		return
	}
	
	
	gl_context = wglCreateContext(device_context)
	
	if !gl_context {
		print("Failed to create gl context")
		return
	}
	
	wglMakeCurrent(device_context, gl_context)
	
	
	load_gl_extensions()
	wglSwapIntervalEXT(0)
	
	glEnable(GL_TEXTURE_2D)
	texture := load_image("chess.bmp")
	
	glEnable(GL_BLEND)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
	ShowWindow(window_handle, show_command)
	
	last_time: s64

	
	QueryPerformanceCounter(*last_time)
	
	moves: [..]Move
	
	making_ai_move := false
	
	while !should_quit {
		current_time: s64
		
		QueryPerformanceCounter(*current_time)
		
		delta := cast() (current_time - last_time) * counter_scale
		
		message: MSG = --
		
		while PeekMessageW(*message, null) {
			if (message.message == WM_QUIT) {
				should_quit = true
				break
			}
			
			TranslateMessage(*message)
			DispatchMessageW(*message)
		}
		
		if undo_last_move {
			undo_last_move = false
			
			if (!black_difficulty || !white_difficulty) && undo_list.count {
				undo_move()
			
				if get_player_difficulty() undo_move()
			}
		}
		
		if game_over
			selected_square = -1
		
		if !game_over {
			if get_player_difficulty() {
				if making_ai_move {
					result := WaitForSingleObject(ai_stop_semaphore, 0)
					if result != WAIT_TIMEOUT {
						if ai_move.piece_index == -1 {
							print("Bad\n")
							game_over = true
						} else {
							make_move(ai_move)
						}
						
						making_ai_move = false
					}
				} else {
					ReleaseSemaphore(ai_start_semaphore)
					making_ai_move = true
				}
		} else if selected_square != -1 {
				for moves {
					if it.end == selected_square {
						selected_square = -1
						make_move(it)
						
						break
					}
				} or {
					piece := get_piece(global_board, selected_square)
					
					if !piece || piece & BLACK != global_board.player_color {
						selected_square = -1
					} else {
						piece_index: s8
						
						moves.count = 0
						get_moves_for_piece(global_board, *moves, global_board.board[selected_square])
					}
				}
			}
		}
		
		if selected_square == -1 {
			moves.count = 0
		}
		
		draw(moves)
		
		if (delta > 1.0 / 55) {
			print("%\n", delta)
		}
		
		SwapBuffers(device_context)
		
		last_time = current_time
	}
	
	exit(0)
}

#import "Compiler"

setup_build :: () {
	arguments := get_build_arguments()
	
	if arguments {
		options := get_build_options()
		options.backend = .LLVM
		options.llvm_options = arguments
		
		set_build_options(options)
	}
}

#run setup_build()