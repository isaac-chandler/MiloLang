#import "Standard"
#import "File"
#import "String"
#import "Table"

#load "lexer.milo"
#load "ast.milo"
#load "parser.milo"

Location :: struct {
    file_id:      s32
    start_offset: s32
    end_offset:   s32
}

// @Workspaces
build_files: [..]string

// @Workspaces
had_error := false

set_start :: (location: *Location, start: Location) {
    location.file_id = start.file_id
    location.start_offset = start.start_offset
}

set_end :: (location: *Location, end: Location) {
    location.end_offset = end.end_offset
}

set_location :: (location: *Location, start: Location, end: Location) {
    set_start(location, start)
    set_end(location, end)
}

report_error :: (location: Location, message: string, format: any..) {
    filename := build_files[location.file_id]
    file_content, success := read_entire_file(filename)
    defer free_array(file_content)
    
    start_line := 1
    start_column := 1
    
    if !success {
        print("Internal Compiler Error: Could not read file '%' to display error location\n", filename)
    } else {
        offset := 0
        
        for file_content[..location.start_offset] {
            start_column += 1
            
            if it == '\r' {
                if it_index + 1 >= file_content.count || file_content[it_index + 1] != '\n' {
                    start_line += 1
                    start_column = 1
                }
            } else if it == '\n' {
                start_line += 1
                start_column = 1
            }
        }
        
        
        
        print("%:%,% ", filename, start_line, start_column)
    }
    
    report_error(message, ..format)
    
    if success {
        start_offset := location.start_offset
        
        while start_offset {
            if file_content[start_offset - 1] == {
                case '\r'
                case '\n'
                    break
            }
            start_offset -= 1
        }
        
        end_offset := location.end_offset
        
        while cast() end_offset < file_content.count {
            if file_content[end_offset] == {
                case '\r'
                case '\n'
                    break
            }
            end_offset += 1
        }
        
        // @Incomplete color precise location
        print("%\e[91m%\e[0m%\n", 
            cast(string) file_content[start_offset..location.start_offset], 
            cast(string) file_content[location.start_offset..location.end_offset], 
            cast(string) file_content[location.end_offset .. end_offset])
    }
}

report_error :: (message: string, format: any..) {
    had_error = true
    
    print("Error: ")
    print(message, ..format)
    print("\n")
}

main :: () {
    arguments := get_command_line_arguments()
    defer free_array(arguments)
    
    if arguments.count == 0 {
        print("Usage: milo <file>\n")
        exit(1)
    }
    
    if arguments.count != 2 {
        print("Usage: % <file>\n", arguments[0])
        exit(1)
    }
    
    content, success := read_entire_file(arguments[1])
    defer free_array(content)
    
    if !success {
        report_error("Failed to read file %", arguments[1])
        exit(1)
    }
    
    array_add(*build_files, arguments[1])
    
    tokens: [..]Token
    success, tokens = lex_string(0, cast() content)
    defer array_free(tokens)
    
    print("%\n", parse(tokens))
}

#import "Compiler"
#run {
    options := get_build_options()
    
    options.output_name = "milo"
    
    set_build_options(options)
}