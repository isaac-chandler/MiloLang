Node :: struct {
    using location: Location
    flags: Flags
    tag: Tag
        
    type_: *Node_Type
    enclosing_function: *Node
    
    substitution: *Node
    
    Tag :: enum u8 {
        NODE
        LOAD
        IMPORT
        DECLARATION
        TYPE
        UNARY
        BINARY
        INT_LITERAL
        FUNCTION
        IDENTIFIER
        BLOCK
        RETURN
        BREAK
        CONTINUE
        REMOVE
        STRUCT_ACCESS
        FUNCTION_CALL
        SLICE
        COMMA_ASSIGNMENT
        DEFER
        IF
        STRING_LITERAL
        FOR
        WHILE
        SWITCH
        RUN
    }
    
    Flags :: enum_flags u16 {
        DECLARATION_USING
        DECLARATION_UNINITIALIZED
        DECLARATION_CONSTANT
        DECLARATION_EXPLICIT_DEFAULT
        DECLARATION_VARARGS
        DECLARATION_COMMA_ASSIGNMENT
        LITERAL_NEGATIVE
        FOR_REVERSE
        FOR_POINTER
        SWITCH_COMPLETE
    }
}

Node_Defer :: struct {
    using node: Node
    
    statement: *Node
}

Node_Switch :: struct {
    using node: Node
    
    value: *Node
    cases: []Case
    
    Case :: struct {
        condition: *Node
        using block: Block
        through: bool
    }
}

Node_String_Literal :: struct {
    using node: Node
    
    text: string
}

Node_If :: struct {
    using node: Node
    
    condition: *Node
    if_body:   *Node
    else_body: *Node
}

Node_Loop_Control :: struct {
    using node: Node
    
    label: string
}

Node_Declaration :: struct {
    using node: Node
    
    name: string
    
    value: *Node
    type_expr: *Node
}

Node_Slice :: struct {
    using node: Node
    
    array: *Node
    begin: *Node
    end:   *Node
}

Node_Struct_Access :: struct {
    using node: Node
    
    value: *Node
    name: string
}

Node_Unary :: struct {
    using node: Node
    
    value: *Node
    op: Token.Tag
}

Node_Binary :: struct {
    using node: Node
    
    left: *Node
    right: *Node
    op: Token.Tag
}

Node_Int_Literal :: struct {
    using node: Node
    
    value: u64
}

Node_Load_Or_Import :: struct {
    using node: Node
    
    name: string
}

Node_Function :: struct {
    using node: Node
    
    constants := Block.{block_tag = .CONSTANTS}
    arguments := Block.{block_tag = .ARGUMENTS}
    returns   := Block.{block_tag = .RETURNS}
    
    body: *Node
}

Node_Function_Call :: struct {
    using node: Node
    
    function: *Node
    arguments: []Named_Argument
}

Node_Comma_Assignment :: struct {
    using node: Node
    
    assign_to: []*Node
    function_call: *Node_Function_Call
    
}

Node_Identifier :: struct {
    using node: Node
    
    name: string
}

Node_Block :: struct {
    using node: Node
    
    using block: Block
}

Named_Argument :: struct {
    value: *Node
    name: string
    declaration: *Node_Declaration
    spread: bool
}

Node_For :: struct {
    using node: Node
    
    iterator_block: Block
    
    begin: *Node
    end:   *Node
    
    body: *Node
}

Node_While :: struct {
    using node: Node
    
    label: string
    
    condition: *Node
    
    body: *Node
}

Node_Type :: struct {
    using node: Node
    
    type_tag: Type_Tag
    type_flags: Type_Flags
    size := -1
    align := -1
    array_count := -1
    members: Block
    
    Type_Tag :: enum u8 {
        POINTER
        ARRAY
        ENUM
        ENUM_FLAGS
        STRUCT
        INTEGER
        FLOAT
        BOOL
        TYPE
        STRING
    }
    
    Type_Flags :: enum_flags u8 {
        UNION
        DYNAMIC_ARRAY
        PACKED
        SIGNED
    }
}

Block :: struct {
    block_tag: Block_Tag
    statements: [..]*Node
    
    Block_Tag :: enum u8 {
        GLOBAL
        ARGUMENTS
        RETURNS
        CONSTANTS
        IMPERATIVE
        ENUM
        STRUCT
    }
}

type_type   := Node_Type.{.{tag = .TYPE}, type_tag = .TYPE,   size = 8,  align = 8}
type_bool   := Node_Type.{.{tag = .TYPE}, type_tag = .BOOL,   size = 1,  align = 1}
type_string := Node_Type.{.{tag = .TYPE}, type_tag = .STRING, size = 16, align = 8}

type_context := Node_Type.{.{tag = .TYPE}, type_tag = .STRUCT}

type_u8  := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 1, align = 1}
type_u16 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 2, align = 2}
type_u32 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 4, align = 4}
type_u64 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 8, align = 8}
type_s8  := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 1, align = 1, type_flags = .SIGNED}
type_s16 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 2, align = 2, type_flags = .SIGNED}
type_s32 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 4, align = 4, type_flags = .SIGNED}
type_s64 := Node_Type.{.{tag = .TYPE}, type_tag = .INTEGER, size = 8, align = 8, type_flags = .SIGNED}
type_f32 := Node_Type.{.{tag = .TYPE}, type_tag = .FLOAT,   size = 4, align = 4}
type_f64 := Node_Type.{.{tag = .TYPE}, type_tag = .FLOAT,   size = 8, align = 8}

create_builtin_types :: () {
    type_type   = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .TYPE,   size = 8,  align = 8}
    type_bool   = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .BOOL,   size = 1,  align = 1}
    type_string = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .STRING, size = 16, align = 8}
    
    type_context = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .STRUCT}
    
    type_u8  = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 1, align = 1}
    type_u16 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 2, align = 2}
    type_u32 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 4, align = 4}
    type_u64 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 8, align = 8}
    type_s8  = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 1, align = 1, type_flags = .SIGNED}
    type_s16 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 2, align = 2, type_flags = .SIGNED}
    type_s32 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 4, align = 4, type_flags = .SIGNED}
    type_s64 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .INTEGER, size = 8, align = 8, type_flags = .SIGNED}
    type_f32 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .FLOAT,   size = 4, align = 4}
    type_f64 = Node_Type.{.{tag = .TYPE, type_ = *type_type}, type_tag = .FLOAT,   size = 8, align = 8}
    
}