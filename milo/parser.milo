Parser :: struct {
    tokens: []Token
    loop_stack: [..]*Node
    current_function: *Node_Function
}

new_node :: (using paser: *Parser, $T: type, tag: Node.Tag) -> *T {
    node := new(T)
    
    node.tag = tag
    node.location = tokens[0]
    
    return node
}

parse :: (tokens_: []Token) -> bool {
    using parser := Parser.{tokens = tokens_}
    defer array_free(parser.loop_stack)

    while tokens {
        if check_and_consume(*parser, ';') {
            tokens = tokens[1..]
            continue
        } else if tokens[0].tag == .END_OF_FILE {
            break
        }
        
        statement := parse_statement(*parser, imperative = false, allow_single_declaration = true)
        
        if !statement
            return false
               
    } or {
        report_error("Internal Error: Ran out of tokens without encountering an end of file")
        return false
    }
    
    return true
}

looks_like_declaration :: (tokens: []Token) -> bool {
    if tokens.count < 2 
        return false
    
    if tokens[0].tag == .MUST
        return true
    else if tokens[0].tag == .USING && tokens.count >= 3
        return tokens[1].tag == .IDENTIFIER && tokens[2].tag == cast() ':'
    else
        return tokens[0].tag == .IDENTIFIER && tokens[1].tag == cast() ':'
}

loop_control_name :: (tag: Token.Tag) -> string {
    if tag == {
        case .REMOVE
            return "remove"
        case .BREAK
            return "break"
        case .CONTINUE
            return "continue"
        else
            assert(false)
            return "unknown loop control"
    }
}

parse_declaration :: (using parser: *Parser) -> *Node {
    declaration := new_node(parser, Node_Declaration, .DECLARATION)
    
    if check_and_consume(parser, .USING)
        declaration.flags |= .DECLARATION_USING
    
    if tokens[0].tag != .IDENTIFIER {
        report_error(tokens[0], "Internal Error: Tried to parse a declaration but didn't find the name")
        return null
    }
    
    declaration.name = tokens[0].string_value
    tokens = tokens[1..]
    
    if !check_and_consume(parser, ':') {
        report_error(tokens[0], "Internal Error: Tried to parse a declaration but didn't find the :")
        return null
    }
    
    if check_and_consume(parser, ':') {
        declaration.flags |= .DECLARATION_CONSTANT
        
        if tokens[0].tag == .UNINITIALIZED {
            report_error(tokens[0], "The type of an uninitialized declaration must be specified")
            return null
        } else if tokens[0].tag == .DOUBLE_DOT {
            report_error(tokens[0], "The type of an explicitly defaulted declaration must be specified")
            return null
        }
        
        declaration.value = parse_expression(parser)
        if !declaration.value return null
        
        set_end(declaration, declaration.value)
    } else if check_and_consume(parser, '=') { 
        if tokens[0].tag == .UNINITIALIZED {
            report_error(tokens[0], "The type of an uninitialized declaration must be specified")
            return null
        } else if tokens[0].tag == .DOUBLE_DOT {
            report_error(tokens[0], "The type of an explicitly defaulted declaration must be specified")
            return null
        }
        
        declaration.value = parse_expression(parser)
        if !declaration.value return null
        
        set_end(declaration, declaration.value)
    } else {
        declaration.type_expr = parse_expression(parser)
        
        if !declaration.type_expr return null
        
        // @BreakingChange @Incomplete (breaking change is not implemented yet) 
        // Varargs before the type specifier makes more logical sense then this 
        // since it is more consistent with array syntax
        if tokens[0].tag == .DOUBLE_DOT {
            set_end(declaration, tokens[0])
            tokens = tokens[1..]
            declaration.flags |= .DECLARATION_VARARGS
        } else if check_and_consume(parser, ':') {
            declaration.flags |= .DECLARATION_CONSTANT
            
            if tokens[0].tag == .UNINITIALIZED {
                report_error(tokens[0], "A constant declaration must be initialized")
                return null
            } else if tokens[0].tag == .DOUBLE_DOT {
                declaration.flags |= .DECLARATION_EXPLICIT_DEFAULT
                set_end(declaration, tokens[0])
                tokens = tokens[1..]
            } else {
                declaration.value = parse_expression(parser)
                if !declaration.value return null
                
                set_end(declaration, declaration.value)
            }
        } else if check_and_consume(parser, '=') {
            if tokens[0].tag == .UNINITIALIZED {
                declaration.flags |= .DECLARATION_UNINITIALIZED
                set_end(declaration, tokens[0])
                tokens = tokens[1..]
            } else if tokens[0].tag == .DOUBLE_DOT {
                declaration.flags |= .DECLARATION_EXPLICIT_DEFAULT
                set_end(declaration, tokens[0])
                tokens = tokens[1..]
            } else {
                declaration.value = parse_expression(parser)
                if !declaration.value return null
                
                set_end(declaration, declaration.value)
            }
        } else {
            set_end(declaration, declaration.type_expr)
        }
    }
    
    return declaration
}

check_and_consume :: (using parser: *Parser, token: Token.Tag) -> bool {
    if tokens[0].tag == token {
        tokens = tokens[1..]
        return true
    }
    
    return false
}

check_and_consume :: (using parser: *Parser, token: u8) -> bool {
    return check_and_consume(parser, cast(Token.Tag) token)
}

parse_import :: (using parser: *Parser) -> *Node {
    import := new_node(parser, Node_Load_Or_Import, .IMPORT)
    
    tokens = tokens[1..]
    
    if tokens[0].tag != .STRING_LITERAL {
        report_error(tokens[0], "Expected string literal module name after #import")
        return null
    }
    
    import.name = tokens[0].string_value
    
    set_end(import, tokens[0])
    
    tokens = tokens[1..]
    
    return import
}

parse_load :: (using parser: *Parser) -> *Node {
    load := new_node(parser, Node_Load_Or_Import, .LOAD)
    
    tokens = tokens[1..]
    
    if tokens[0].tag != .STRING_LITERAL {
        report_error(tokens[0], "Expected string literal file name after #load")
        return null
    }
    
    load.name = tokens[0].string_value
    
    set_end(load, tokens[0])
    
    tokens = tokens[1..]
    
    return load
}

parse_add_context :: (using parser: *Parser) -> *Node {
    report_error(tokens[0], "Add context parsing is not implemented")
    return null
}

parse_static_if :: (using parser: *Parser, imperative: bool, struct_body: bool) -> *Node {
    report_error(tokens[0], "Static if parsing is not implemented")
    return null
}

parse_using :: (using parser: *Parser) -> *Node {
    report_error(tokens[0], "Using parsing is not implemented")
    return null
}

parse_for :: (using parser: *Parser) -> *Node {
    for_ := new_node(parser, Node_For, .FOR)
    
    tokens = tokens[1..]
    
    if check_and_consume(parser, '<') {
        for_.flags |= .FOR_REVERSE
        
        if check_and_consume(parser, '*')
            for_.flags |= .FOR_POINTER
    } else if check_and_consume(parser, '*') {
        for_.flags |= .FOR_POINTER
        
        if check_and_consume(parser, '<')
            for_.flags |= .FOR_REVERSE       
    }
    
    if tokens.count >= 2 && tokens[0].tag == .IDENTIFIER && tokens[1].tag == cast() ':' {
        it := new_node(parser, Node_Declaration, .DECLARATION)
        it.name = tokens[0].string_value
        
        array_add(*for_.iterator_block.statements, it)
        
        tokens = tokens[2..]
    } else if tokens.count >= 2 && tokens[0].tag == .IDENTIFIER && tokens[1].tag == cast() ',' {
        it := new_node(parser, Node_Declaration, .DECLARATION)
        it.name = tokens[0].string_value
        
        array_add(*for_.iterator_block.statements, it)
        
        tokens = tokens[2..]
        
        it_index := new_node(parser, Node_Declaration, .DECLARATION)
        it_index.name = tokens[0].string_value
        
        array_add(*for_.iterator_block.statements, it_index)
    
        tokens = tokens[2..]
    } else {
        it := new_node(parser, Node_Declaration, .DECLARATION)
        it.location = for_
        it.name = tokens[0].string_value
        
        array_add(*for_.iterator_block.statements, it)
    }
    
    for_.begin = parse_expression(parser)
    if !for_.begin return null
    
    if check_and_consume(parser, .DOUBLE_DOT) {
        for_.end = parse_expression(parser)
        if !for_.end return null
        
        set_end(for_, for_.end)
    } else {
        set_end(for_, for_.begin)
    }
    
    for_.body = parse_statement(parser, imperative = true, allow_single_declaration = false)
    if !for_.body return null
    
    return for_
}


parse_while :: (using parser: *Parser) -> *Node {
    while_ := new_node(parser, Node_While, .WHILE)
    
    tokens = tokens[1..]
    
    if tokens.count >= 2 && tokens[0].tag == .IDENTIFIER && tokens[1].tag == cast() ':' {
        while_.label = tokens[0].string_value
        tokens = tokens[2..]
    }
    
    while_.condition = parse_expression(parser)
    if !while_.condition return null
    
    set_end(while_, while_.condition)
    
    while_.body = parse_statement(parser, imperative = true, allow_single_declaration = false)
    if !while_.body return null
    
    return while_
}

parse_loop_control :: (using parser: *Parser) -> *Node {
    kind: Node.Tag
    
    if tokens[0].tag == {
        case .BREAK     kind = .BREAK
        case .CONTINUE  kind = .CONTINUE
        case .REMOVE    kind = .REMOVE
        else assert(false)
    }
    
    loop_control := new_node(parser, Node_Loop_Control, kind)
    tokens = tokens[1..]
    
    if tokens[0].tag == .IDENTIFIER && !looks_like_declaration(parser.tokens) {
        loop_control.label = tokens[0].string_value
        set_end(loop_control, tokens[0])
        
        tokens = tokens[1..]
    }
    
    return loop_control
}

parse_if :: (using parser: *Parser) -> *Node {
    start := tokens[0].location
    
    tokens = tokens[1..]
    
    condition := parse_expression(parser)
    if !condition return null
    
    if check_and_consume(parser, .EQUAL) {
        switch := new_node(parser, Node_Switch, .SWITCH)
        switch.value = condition
        set_start(switch, start)
        
        if check_and_consume(parser, .COMPLETE)
            switch.flags |= .SWITCH_COMPLETE
        
        set_end(switch, tokens[-1])
        
        if !check_and_consume(parser, '{') {
            report_error(tokens[0], "Expected '{' to start if-case block")
            return null
        }
        
        cases: [..]Node_Switch.Case
        defer array_free(cases)
        
        had_else := false
        
        while true {
            case_: Node_Switch.Case
            
            if check_and_consume(parser, '}')
                break
            else if check_and_consume(parser, .CASE) {
                case_.condition = parse_expression(parser)
                if !case_.condition return null
            } else if check_and_consume(parser, .ELSE) {
                if had_else {
                    report_error(tokens[-1], "Cannot have multiple else blocks in an if-case")
                    return null
                }
                
                had_else = true
            } else {
                report_error(tokens[0], "Expected case or else block in if-case statement")
                return null
            }
                        
            while true {
                if check_and_consume(parser, .THROUGH) {
                    case_.through = true
                    break
                }
                
                if tokens[0].tag == .CASE || tokens[0].tag == .ELSE || tokens[0].tag == cast() '}'
                    break;
                    
                if check_and_consume(parser, ';')
                    continue;
                
                statement := parse_statement(parser, imperative = true, allow_single_declaration = true)
                if !statement return null
                
                array_add(*case_.statements, statement)
            }
            
            
            array_add(*cases, case_)
        }
        
        switch.cases = array_copy(cases)
        
        return switch
    } else {
        if_ := new_node(parser, Node_If, .IF)
        if_.condition = condition
        set_start(if_, start)
        set_end(if_, if_.condition)
        
        if_.if_body = parse_statement(parser, imperative = true, allow_single_declaration = false)
        if !if_.if_body return null
        
        if !check_and_consume(parser, .ELSE)
            return if_
            
        if_.else_body = parse_statement(parser, imperative = true, allow_single_declaration = false)
        if !if_.else_body return null
        
        return if_
    }
}

parse_defer :: (using parser: *Parser) -> *Node {
    defer_ := new_node(parser, Node_Defer, .DEFER)
    
    tokens = tokens[1..]

    defer_.statement = parse_statement(parser, imperative = true, allow_single_declaration = false)
    if !defer_.statement return null
    
    set_end(defer_, defer_.statement)
    
    return defer_
}

parse_primitive_type :: (using parser: *Parser, type_: *Node_Type) -> *Node {
    node := new_node(parser, Node, .NODE)
    node.substitution = type_
    node.type_ = *type_type
    tokens = tokens[1..]
    return node
}

parse_int_literal :: (using parser: *Parser, value: u64, type_: *Node_Type) -> *Node {
    node := new_node(parser, Node_Int_Literal, .INT_LITERAL)
    node.type_ = type_
    node.value = value
    tokens = tokens[1..]
    return node
}

parse_named_arguments :: (using parser: *Parser, allow_uninitialized := false) -> 
                         (#must arguments: []Named_Argument, #must success: bool, uninitialized: bool) {
    arguments_buffer: [..]Named_Argument
    defer array_free(arguments_buffer)
    
    uninitialized := false
    
    while true {
        if tokens[0].tag == .UNINITIALIZED {
            if allow_uninitialized {
                uninitialized = true
                tokens = tokens[1..]
                continue
            } else {
                report_error(tokens[0], "Only struct literal arguments can be uninitialized")
                return .{}, false, false
            }
        } else {
            if uninitialized {
                report_error(tokens[0], "Cannot have more arguments after a '--' specifier")
                return .{}, false, false
            }
            
            argument: Named_Argument
            
            if tokens.count >= 2 && tokens[0].tag == .IDENTIFIER && tokens[1].tag == cast() '=' {
                argument.name = tokens[0].string_value
                tokens = tokens[2..]
            }
            
            argument.spread = check_and_consume(parser, .DOUBLE_DOT)
            
            argument.value = parse_expression(parser)
            if !argument.value return .{}, false, false
            
            array_add(*arguments_buffer, argument)
        }
        
        if !check_and_consume(parser, ',')
            break
        
    }
    
    return array_copy(arguments_buffer), true, uninitialized
}

parse_postfix_expression :: (using parser: *Parser) -> *Node {
    expression := parse_primary_expression(parser)
    if !expression return null
    
    while true {
        if check_and_consume(parser, '.') {
            if tokens[0].tag == .IDENTIFIER {
                struct_access := new_node(parser, Node_Struct_Access, .STRUCT_ACCESS)
                set_start(struct_access, expression)
                struct_access.value = expression
                struct_access.name = tokens[0].string_value
                tokens = tokens[1..]
                
                expression = struct_access
            } else if check_and_consume(parser, '[') {
                report_error(tokens[0], "Array literal parsing is not implemented")
                return null
            } else if check_and_consume(parser, '{') {
                report_error(tokens[0], "Struct literal parsing is not implemented")
                return null
            } else {
                report_error(tokens[0], "Expected struct access, array literal or struct literal after '.'")
                return null
            }
        } else if check_and_consume(parser, '(') {
            function_call := new_node(parser, Node_Function_Call, .FUNCTION_CALL)
            function_call.function = expression
            set_start(function_call, expression)
            
            if tokens[0].tag != cast() ')' {
                success: bool
                function_call.arguments, success = parse_named_arguments(parser)
                if !success return null
            }
            
            set_end(function_call, tokens[0]) 
            if !check_and_consume(parser, ')') {
                report_error(tokens[0], "Expected ')' or another argument")
                return null
            }
            
            expression = function_call
        } else if check_and_consume(parser, '[') {
            if check_and_consume(parser, .DOUBLE_DOT) {
                slice := new_node(parser, Node_Slice, .SLICE)
                set_start(slice, expression)
                slice.array = expression
                
                slice.end = parse_expression(parser)
                if !slice.end return null
                
                set_end(slice, tokens[0])
                if !check_and_consume(parser, ']') {
                    report_error(tokens[0], "Expected ']' after slice end")
                    return null
                }
                
                expression = slice
            } else {
                index := parse_expression(parser)
                if !index return null
                
                if check_and_consume(parser, .DOUBLE_DOT) {
                    slice := new_node(parser, Node_Slice, .SLICE)
                    set_start(slice, expression)
                    slice.array = expression
                    
                    if tokens[0].tag == cast() ']' {
                        slice.begin = index
                        
                        tokens = tokens[1..]
                    } else {
                        slice.end = parse_expression(parser)
                        if !slice.end return null
                        
                        set_end(slice, slice.end)
                        
                        if !check_and_consume(parser, ']') {
                            report_error(tokens[0], "Expected ']' after slice end")
                        }
                    }
                    
                    expression = slice
                } else {
                    binary := new_node(parser, Node_Binary, .BINARY)
                    binary.op = .INDEX
                    binary.left = expression
                    binary.right = index
                    set_start(binary, binary.left)
                    set_end(binary, binary.right)
                    
                    if !check_and_consume(parser, ']') {
                        report_error(tokens[0], "Expected ']' after array index")
                        return null
                    }
                    
                    expression = binary
                }
            }
        } else {
            break
        }
    }
        
    // TODO postfix expressions
    return expression
}

parse_prefix_expression :: (using parser: *Parser) -> *Node {
    start := tokens[0].location
    
    if check_and_consume(parser, '[') {
        if check_and_consume(parser, .DOUBLE_DOT) {
            if !check_and_consume(parser, ']') {
                report_error(tokens[0], "Expected ']' after '..' in dynamic array type")
                return null
            }
            
            unary := new_node(parser, Node_Unary, .UNARY)
            set_start(unary, start)
            unary.op = .DYNAMIC_ARRAY_OF
            
            unary.value = parse_prefix_expression(parser)
            if !unary.value return null
            
            set_end(unary, unary.value)
            return unary
        } else if check_and_consume(parser, ']') {
            unary := new_node(parser, Node_Unary, .UNARY)
            set_start(unary, start)
            unary.op = .ARRAY_OF
            
            unary.value = parse_prefix_expression(parser)
            if !unary.value return null
            
            set_end(unary, unary.value)
            return unary
        } else {
            binary := new_node(parser, Node_Binary, .BINARY)
            set_start(binary, start)
            binary.op = .ARRAY_OF
            
            binary.left = parse_expression(parser)
            if !binary.left return null
            
            if !check_and_consume(parser, ']') {
                report_error(tokens[0], "Expected ']' after static array count")
                return null
            }
            
            binary.right = parse_prefix_expression(parser)
            if !binary.right return null
            
            set_end(binary, binary.right)
            return binary
        }
    } else if check_and_consume(parser, '*') {
        unary := new_node(parser, Node_Unary, .UNARY)
        set_start(unary, start)
        unary.op = cast() '*'
        
        unary.value = parse_prefix_expression(parser)
        if !unary.value return null
        return unary
    } else if check_and_consume(parser, '!') {
        unary := new_node(parser, Node_Unary, .UNARY)
        set_start(unary, start)
        unary.op = cast() '!'
        
        unary.value = parse_prefix_expression(parser)
        if !unary.value return null
        return unary
    } else if check_and_consume(parser, .CAST) {
        if !check_and_consume(parser, '(') {
            report_error(tokens[0], "Expected '(' after 'cast'")
        }
        
            
        if check_and_consume(parser, ')') {
            unary := new_node(parser, Node_Unary, .UNARY)
            set_start(unary, start)
            unary.op = .CAST
            unary.value = parse_prefix_expression(parser)
            if !unary.value return null
            set_end(unary, unary.value)
            
            return unary
        }
        
        binary := new_node(parser, Node_Binary, .BINARY)
        set_start(binary, start)
        binary.op = .CAST
        binary.left = parse_expression(parser)
        
        if !check_and_consume(parser, ')') {
            report_error(tokens[0], "Expected ')' after cast type")
            return null
        }
        
        binary.right = parse_prefix_expression(parser)
        if !binary.right return null
        set_end(binary, binary.right)
        
        return binary
    } else {
        return parse_postfix_expression(parser)
    }
}

parse_multiply_expression :: (using parser: *Parser) -> *Node {
    expression := parse_prefix_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case cast() '*' #through
            case cast() '/' #through
            case cast() '%'
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_prefix_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_add_expression :: (using parser: *Parser) -> *Node {
    expression := parse_multiply_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case cast() '+' #through
            case cast() '-'
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_multiply_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_bitwise_expression :: (using parser: *Parser) -> *Node {
    expression := parse_add_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case cast() '&' #through
            case cast() '|' #through
            case cast() '^'
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_add_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_shift_expression :: (using parser: *Parser) -> *Node {
    expression := parse_bitwise_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case .SHIFT_LEFT #through
            case .SHIFT_RIGHT
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_bitwise_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_compare_expression :: (using parser: *Parser) -> *Node {
    expression := parse_shift_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case .EQUAL
                if tokens.count >= 2 && (tokens[1].tag == cast() '{' || tokens[1].tag == .COMPLETE)
                    break
                #through
            case .NOT_EQUAL     #through
            case .LESS_EQUAL    #through
            case .GREATER_EQUAL #through
            case cast() '<'     #through
            case cast() '>'
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_shift_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_short_circuit_expression :: (using parser: *Parser) -> *Node {
    expression := parse_compare_expression(parser)
    if !expression return null
    
    while true {
        if tokens[0].tag == {
            case .LOGIC_AND #through
            case .LOGIC_OR
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.op = tokens[0].tag
                binary.left = expression
                set_start(binary, binary.left)
                
                tokens = tokens[1..]
                
                binary.right = parse_compare_expression(parser)
                if !binary.right return null
                
                expression = binary
            else
                break
        }
    }
    
    return expression
}

parse_expression :: parse_short_circuit_expression

parse_named_argument_declarations :: (using parser: *Parser, block: *Block) -> bool {
    while tokens[0].tag != cast() ')' {
        must := check_and_consume(parser, .MUST)
        
        if must && block.block_tag != .RETURNS {
            report_error(tokens[0], "Only return values can be marked as #must")
            return false
        }
        
        declaration := parse_declaration(parser)
        if !declaration return false
        
        if declaration.flags & .DECLARATION_USING && block.block_tag == .RETURNS {
            report_error(tokens[0], "Return values cannot be marked as using")
            return false
        }
        
        if declaration.flags & .DECLARATION_VARARGS && block.block_tag == .RETURNS {
            report_error(tokens[0], "Return values cannot be variable length")
            return false
        }
        
        if declaration.flags & .DECLARATION_CONSTANT {
            report_error(tokens[0], "Arguments or returns cannot be constant values")
            return false
        }
        
        if declaration.flags & .DECLARATION_UNINITIALIZED {
            report_error(tokens[0], "Arguments or returns cannot be uninitialized")
            return false
        }
        
        array_add(*block.statements, declaration)
        
        if tokens[0].tag == cast() ')' 
            return true
        else if !check_and_consume(parser, ',') {
            report_error(tokens[0], "Expected ',' or ')' in argument or return list")
            return false
        }
    }
    
    return true
}


parse_unnamed_argument_declarations :: (using parser: *Parser, block: *Block) -> bool {
    while tokens[0].tag != cast() ')' {
        expression := parse_expression(parser)
        if !expression return false
        
        declaration := create_unnamed_argument_declaration(parser, expression)
        
        // @BreakingChange @Incomplete (breaking change is not implemented yet) 
        // Varargs before the type specifier makes more logical sense then this 
        // since it is more consistent with array syntax
        if tokens[0].tag == .DOUBLE_DOT {
            if block.block_tag == .RETURNS {
                report_error(tokens[0], "Return values cannot be variable length")
                return false
            }
            
            set_end(declaration, tokens[0])
            declaration.flags |= .DECLARATION_VARARGS
            tokens = tokens[1..]
        }
        
        array_add(*block.statements, declaration)
        
        if tokens[0].tag == cast() ')' 
            return true
        else if !check_and_consume(parser, ',') {
            report_error(tokens[0], "Expected ',' or ')' in argument or return list")
            return false
        }
    }
    
    return true
}

create_unnamed_argument_declaration :: (using parser: *Parser, type_: *Node) -> *Node_Declaration {
    declaration := new_node(parser, Node_Declaration, .DECLARATION)
    declaration.location = type_.location
    declaration.type_expr = type_
    
    return declaration
}

parse_function :: (using parser: *Parser) -> *Node {
    start := tokens[0].location
    end   := tokens[0].location
    
    tokens = tokens[1..]
    
    function: *Node_Function
    expression: *Node
    
    named_arguments := looks_like_declaration(tokens) || tokens[0].tag == cast() ')'
    if named_arguments {    
        function = new_node(parser, Node_Function, .FUNCTION)
        
        if !parse_named_argument_declarations(parser, *function.arguments) return null
        
        end = tokens[0]
        tokens = tokens[1..] // closing ')' is not consumed
    } else {
        expression = parse_expression(parser)
        if !expression return null
        
        end = tokens[0]
        
        if check_and_consume(parser, ',') {
            function = new_node(parser, Node_Function, .FUNCTION)
            array_add(*function.arguments.statements, create_unnamed_argument_declaration(parser, expression))
            if !parse_unnamed_argument_declarations(parser, *function.arguments) return null
            
            end = tokens[0]
            tokens = tokens[1..] // closing ')' is not consumed
        } else if !check_and_consume(parser, ')') {
            report_error(tokens[0], "Expected ')'")
            return null
        }
    }
    
    explicit_returns := check_and_consume(parser, .ARROW)
    if explicit_returns {
        if !function {
            function = new_node(parser, Node_Function, .FUNCTION)
            array_add(*function.arguments.statements, create_unnamed_argument_declaration(parser, expression))
        }
        
        if check_and_consume(parser, '(') {
            if looks_like_declaration(tokens) || tokens[0].tag == cast() ')'
                if !parse_named_argument_declarations(parser, *function.returns) return null
            else
                if !parse_unnamed_argument_declarations(parser, *function.arguments) return null
            
            end = tokens[0]
            tokens = tokens[1..] // closing ')' is not consumed
        } else {
            return_type := parse_expression(parser)
            if !return_type return null
            
            array_add(*function.returns.statements, create_unnamed_argument_declaration(parser, return_type))
        }
    }
    
    if !function
        return expression
    
    set_start(function, start)
    set_end(function, end)
    
    if tokens[0].tag == cast() '{' {
        if !named_arguments {
            report_error(function, "Functions cannot have unnamed arguments")
            return null
        }
        
        old_function := currernt_function
        defer current_function = old_function
        
        current_function = function
        function.body = parse_block(parser, imperative = true)
        if !function.body return null
    } else {
        if !explicit_returns {
            report_error(function, "Function types must explicitly specify an empty return list '-> ()' if they have no returns")
            return null
        }
    }
    
    return function
}

parse_primary_expression :: (using parser: *Parser) -> *Node {
    if tokens[0].tag == {
        case .STRUCT #through
        case .UNION
            struct_ := new_node(parser, Node_Type, .TYPE)
            struct_.type_tag = .STRUCT
            struct_.members.block_tag = .STRUCT
            
            if tokens[0].tag == .UNION
                struct_.type_flags |= .UNION
            
            tokens = tokens[1..]
            
            if check_and_consume(parser, .PACK)
                struct_.type_flags |= .PACKED
            
            if !check_and_consume(parser, '{') {
                kind := "struct"
                
                if struct_.type_flags & .UNION
                    kind = "union"
                
                report_error(tokens[0], "Expected '{' at start of % definition", kind)
                return null
            }
            
            while true {
                if tokens[0].tag == cast() '}' {
                    break
                } else if tokens[0].tag == cast() ';' {
                    tokens = tokens[1..]
                    continue
                }
                
                statement := parse_statement(parser, imperative = false, allow_single_declaration = true, struct_body = true)
                
                if !statement return null
                
                array_add(*struct_.members.statements, statement)
            }
            
            set_end(struct_, tokens[0])
            tokens = tokens[1..]
            return struct_
        case .TYPE
            return parse_primitive_type(parser, *type_type)
        case .BOOL
            return parse_primitive_type(parser, *type_bool)
        case .STRING
            return parse_primitive_type(parser, *type_string)
        case .CONTEXT_TYPE
            return parse_primitive_type(parser, *type_context)
        case .U8
            return parse_primitive_type(parser, *type_u8)
        case .U16
            return parse_primitive_type(parser, *type_u16)
        case .U32
            return parse_primitive_type(parser, *type_u32)
        case .U64
            return parse_primitive_type(parser, *type_u64)
        case .S8
            return parse_primitive_type(parser, *type_s8)
        case .S16
            return parse_primitive_type(parser, *type_s16)
        case .S32
            return parse_primitive_type(parser, *type_s32)
        case .S64
            return parse_primitive_type(parser, *type_s64)
        case .F32
            return parse_primitive_type(parser, *type_f32)
        case .F64
            return parse_primitive_type(parser, *type_f64)
        case .FALSE
            return parse_int_literal(parser, 0, *type_bool)
        case .TRUE
            return parse_int_literal(parser, 1, *type_bool)
        case .INT_LITERAL
            return parse_int_literal(parser, tokens[0].integer_value, null)
        case cast() '('
            return parse_function(parser)
        case .IDENTIFIER
            identifier := new_node(parser, Node_Identifier, .IDENTIFIER)
            identifier.name = tokens[0].string_value
            
            tokens = tokens[1..]
            return identifier
        case .STRING_LITERAL
            literal := new_node(parser, Node_String_Literal, .STRING_LITERAL)
            literal.text = tokens[0].string_value
            
            tokens = tokens[1..]
            return literal
        case .RUN
            run := new_node(parser, Node_Function, .RUN)
            tokens = tokens[1..]
            
            old_function := current_function
            defer current_function = old_function
            
            current_function = run
            
            if tokens[0].tag == cast() '{'
                run.body = parse_block(parser, imperative = true)
            else
                run.body = parse_expression(parser)
    
            if !run.body return null
            
            return run
        else
            report_error(tokens[0], "Expected an expression")
            return null
    }
}

parse_block :: (using parser: *Parser, imperative: bool) -> *Node_Block {
    block := new_node(parser, Node_Block, .BLOCK)
    
    if imperative
        block.block_tag = .IMPERATIVE
    else
        block.block_tag = .GLOBAL    
    
    tokens = tokens[1..]
    
    had_exiting_statement := false
    
    while true {
        if tokens[0].tag == cast() '}' {
            set_end(block, tokens[0])
            tokens = tokens[1..]
            return block
        } else if check_and_consume(parser, ';') {
            continue
        }
        
        statement := parse_statement(parser, imperative = imperative, allow_single_declaration = true)
        if !statement return null
        
        if had_exiting_statement {
            report_error(statement, "Unreachable statement")
            return null
        }
        
        array_add(*block.statements, statement)
        
        if statement.tag == {
            case .RETURN #through
            case .BREAK  #through
            case .CONTINUE
                had_exiting_statement = true
        }
    }
    
    return null
}

parse_statement :: (using parser: *Parser, imperative: bool, allow_single_declaration: bool, struct_body := false) -> *Node {
    if looks_like_declaration(tokens) {
        declaration := parse_declaration(parser)
        if !declaration return null
        
        if declaration.flags & .DECLARATION_VARARGS {
            report_error(declaration, "Only function arguments can be marked as variable length")
            return null
        }
        
        if !allow_single_declaration {
            report_error(declaration, "Cannot have a declaration as a single statement, it could neved be used (maybe you meant for this to be an assignment?)")
            return null
        }
        
        return declaration
    } else if tokens[0].tag == .IMPORT {
        if imperative {
            report_error(tokens[0], "Cannot have an unnamed #import in an imperative scope")
            return null
        } else if struct_body {
            report_error(tokens[0], "Cannot have an unnamed #import in a struct")
            return null
        }
    
        return parse_import(parser)
    } else if tokens[0].tag == .LOAD {
        if imperative {
            report_error(tokens[0], "Cannot have a #load in an imperative scope")
            return null
        } else if struct_body {
            report_error(tokens[0], "Cannot have a #load in a struct")
            return null
        }
    
        return parse_load(parser)
    } else if tokens[0].tag == .ADD_CONTEXT {
        if imperative {
            report_error(tokens[0], "Cannot have an #add_context in an imperative scope")
            return null
        } else if struct_body {
            report_error(tokens[0], "Cannot have an #add_context in a struct")
            return null
        }
    
        return parse_add_context(parser)
    } else if tokens[0].tag == .RUN {
        return parse_expression(parser)
    } else if tokens[0].tag == .STATIC_IF {
        return parse_static_if(parser, imperative = imperative, struct_body = struct_body)
    } else if tokens[0].tag == .USING {
        using_ := parse_using(parser)
        if !using_ return null
        
        if !allow_single_declaration {
            report_error(using_, "Cannot have a using as a single statement, it's imports could never be used")
            return null
        }
        
        return using_
    } else if tokens[0].tag == .WHILE {
        if struct_body {
            report_error(tokens[0], "Cannot have a while loop in a struct")
            return null
        } else if !imperative {
            report_error(tokens[0], "Cannot have a while loop at the top level")
            return null
        }
        
        return parse_while(parser)
    } else if tokens[0].tag == .FOR {
        if struct_body {
            report_error(tokens[0], "Cannot have a for loop in a struct")
            return null
        } if !imperative {
            report_error(tokens[0], "Cannot have a for loop at the top level")
            return null
        }
        
        return parse_for(parser)
    }else if tokens[0].tag == .BREAK || tokens[0].tag == .CONTINUE || tokens[0].tag == .REMOVE {
        if struct_body {
            report_error(tokens[0], "Cannot have a % in a struct", loop_control_name(tokens[0].tag))
            return null
        } else if !imperative {
            report_error(tokens[0], "Cannot have a % statement at the top level", loop_control_name(tokens[0].tag))
            return null
        }
        
        return parse_loop_control(parser)
    } else if tokens[0].tag == .IF {
        if struct_body {
            report_error(tokens[0], "Cannot have an if statement in a struct")
            return null
        } else if !imperative {
            report_error(tokens[0], "Cannot have an if statement at the top level")
            return null
        }
        
        return parse_if(parser)
    } else if tokens[0].tag == .DEFER {
        if struct_body {
            report_error(tokens[0], "Cannot have a defer statement in a struct")
            return null
        } else if !imperative {
            report_error(tokens[0], "Cannot have a defer statement at the top level")
            return null
        }
        
        return parse_defer(parser)
    } else if tokens[0].tag == cast() '{' {
        if struct_body {
            report_error(tokens[0], "Cannot have a block in a struct")
            return null
        } else if !imperative {
            report_error(tokens[0], "Cannot have a block at the top level")
            return null
        }
        
        return parse_block(parser, imperative = imperative)
    } else {
        if struct_body {
            report_error(tokens[0], "Expected a struct member")
            return null
        } else if !imperative {
            report_error(tokens[0], "Expected a top level statement")
            return null
        }
        
        expression := parse_expression(parser)
        if !expression return null
        
        token := tokens[0]
        if token.tag == {
            case cast() '='         #through
            case .PLUS_EQUAL        #through
            case .MINUS_EQUAL       #through
            case .TIMES_EQUAL       #through
            case .DIVIDE_EQUAL      #through
            case .MOD_EQUAL         #through
            case .BIT_AND_EQUAL     #through
            case .BIT_OR_EQUAL      #through
            case .XOR_EQUAL         #through
            case .SHIFT_LEFT_EQUAL  #through
            case .SHIFT_RIGHT_EQUAL #through
            case .LOGIC_AND_EQUAL   #through
            case .LOGIC_OR_EQUAL
                binary := new_node(parser, Node_Binary, .BINARY)
                binary.left = expression
                binary.op = token.tag
                
                tokens = tokens[1..]
                
                binary.right = parse_expression(parser)
                if !binary.right return null
                
                set_start(binary, binary.left)
                set_end(binary, binary.right)
                
                return binary
            case cast() ','
                comma_assignment := new_node(parser, Node_Comma_Assignment, .COMMA_ASSIGNMENT)
                set_start(comma_assignment, expression)
                
                expressions: [..]*Node
                defer array_free(expressions)
                
                array_add(*expressions, expression)
                
                tokens = tokens[1..]
            
                while true {
                    assign_to := parse_expression(parser)
                    if !assign_to return null
                    
                    array_add(*expressions, expression)
                    
                    if check_and_consume(parser, ',')
                        continue
                    
                    if check_and_consume(parser, ':') {
                        comma_assignment.flags |= .DECLARATION_COMMA_ASSIGNMENT
                        
                        for expressions {
                            if it.tag != .IDENTIFIER {
                                report_error(it, "Comma declaration names must be an identifier")
                                return null
                            }
                        }
                    }
                    if !check_and_consume(parser, '=') {
                        report_error(tokens[0], "Expected '=' in comma assignment expression")
                        return null
                    }
                    
                    break
                }
                
                comma_assignment.assign_to = array_copy(expressions)
                
                function_call := parse_expression(parser)
                if !function_call return null
                
                if function_call.tag != .FUNCTION_CALL {
                    // @Incomplte What about runs with multiple returns?
                    report_error(function_call, "Only a function call may be on the right hand side of a comma assignment")
                    return null
                }
                
                comma_assignment.function_call = cast() function_call
                set_end(comma_assignment, function_call)
                
                if comma_assignment.flags & .DECLARATION_COMMA_ASSIGNMENT && !allow_single_declaration {
                    report_error(comma_assignment, "Cannot have a declaration as a single statement, it could neved be used (maybe you meant for this to be an assignment?)")
                    return null
                }
                
                return comma_assignment
        }
        
        if expression.tag == .FUNCTION_CALL return expression
    
        report_error(expression, "Only function call expressions can be used as statements. This expression has no side effects")
        return null
    }
}