Function_State :: struct {
	current_function:  *Node_Function
	current_defer:     *Node_Unary_Operator
	context_available: bool
}

Parser :: struct {
	tokens: []Token
	current_block: *Block
	using function_state: Function_State
	module_scope      := false
	end_of_file: Token
	token: Token
	previous_token_loc: Location
}

advance :: (using parser: *Parser) {
	assert(tokens.count != 0)
	tokens = tokens[1..]
	previous_token_loc = token.loc
	token = get_token(parser)
}

consume :: (using parser: *Parser, kind: Token.Kind) -> bool {
	if token.kind == kind {
		advance(parser)
		return true
	}

	return false
}

consume :: (parser: *Parser, kind: Token.Kind.integer) -> bool {
	return consume(parser, cast(Token.Kind) kind)
}

get_token :: (using parser: *Parser, index: u64 = 0) -> Token {
	if index < tokens.count
		return tokens[0]

	return end_of_file
}

create_node :: (using parser: *Parser, $T: type) -> *T {
	node := new(T)

	node.enclosing_block = current_block
	node.loc = token.loc

	return node
}

parse :: (tokens: []Token) -> bool {
	parser := Parser.{tokens = tokens}

	if tokens.count {
		parser.end_of_file = tokens[tokens.count - 1]
		parser.end_of_file.kind = .END_OF_FILE
		parser.end_of_file.l0 = parser.end_of_file.l1
		parser.end_of_file.c0 = parser.end_of_file.c1

		parser.token = get_token(*parser)
	}

	while tokens {
		statement, success := parse_top_level_statement(*parser)
		if !success
			return false
	}

	return true
}

parse_top_level_statement :: (using parser: *Parser) -> (#must *Node, #must bool) {
	if token.kind == {
	case .IDENTIFIER
		declaration := parse_declaration(parser)

		return declaration, declaration != null
	case .SCOPE_MODULE #through
	case .SCOPE_EXPORT
		parse_scope_directive(parser)
		return null, true
	case .USING
		node := parse_declaration_or_using(parser)

		return node, node != null
	case .IMPORT #through
	case .LOAD
		load := parse_load_or_import(parser)

		return load, load != null
	case .STATIC_IF
		static_if := parse_if(parser, statement_kind = .TOP_LEVEL)

		return static_if, static_if != null
	case .ADD_CONTEXT
		add_context := parse_add_context(parser)

		return add_context, add_context != null
	case .RUN
		run := parse_run(parser)

		return run, run != null
	case cast() ';'
		return null, true
	}

	report_expected_error(token, "Error: Expected a top level declaration")
	return null, false
}

parse_declaration_or_using :: (using parser: *Parser) -> *Node {
	if get_token(parser, 1).kind == .IDENTIFIER && get_token(parser, 2).kind == cast() ':' {
		return parse_declaration(parser)
	} else {
		return parse_using(parser)
	}
}

parse_declaration :: (using parser: *Parser) -> *Node_Declaration {
	declaration := create_node(parser, Node_Declaration)

	if module_scope
		declaration.declaration_flags |= .MODULE_SCOPE

	if consume(parser, .USING)
		declaration.declaration_flags |= .USING


	if consume(parser, '$') {
		report_error(token, "Error: Value bakes parsing is not implemented")
		return null
	}

	if token.kind != .IDENTIFIER {
		report_expected_error(token, "Error: Expected declaration name")
		return null
	}

	declaration.text = token.text

	advance(parser)

	if !consume(parser, ':') {
		report_expected_error(token, "Error: Expected ':' after declaration name")
		return null
	}

	if token.kind != cast() ':' && token.kind != cast() '=' {
		declaration.type_value = parse_expr(parser)
		if !declaration.type_value
			return null
	}

	if token.kind == {
	case cast() ':'
		declaration.declaration_flags |= .CONSTANT

		#through
	case cast() '='
		advance(parser)

		if token.kind == .DOUBLE_DASH {
			if declaration.declaration_flags & .CONSTANT {
				report_error(token, "Error: A constant cannot be uninitialized")
				return null
			}

			declaration.declaration_flags |= .UNINITIALIZED
			advance(parser)
		} else if token.kind == .DOUBLE_DOT {
			if !declaration.type_value {
				report_error(token, "Error: No type given for default value")
				return null
			}

			declaration.declaration_flags |= .EXPLICIT_DEFAULT
			advance(parser)
		} else {
			declaration.value = parse_expr(parser)
			if !declaration.value
				return null
		}

	}

	copy_loc_end(declaration, previous_token_loc)

	if declaration.value {
		if declaration.value.kind == {
			case .FUNCTION          #through
			case .STRUCT_DEFINITION #through
			case .ENUM_DEFINITION
				declaration.value.text = declaration.text
		}
	}

	return declaration
}

parse_using :: (using parser: *Parser) -> *Node_Load {
	assert(token.kind == .USING)
	using_ := create_node(parser, Node_Load)
	using_.kind = .USING

	advance(parser)

	using_.value = parse_expr(parser)
	if !using_.value
		return null

	copy_loc_end(using_, using_.value)
	return using_
}

parse_scope_directive :: (using parser: *Parser) {
	if token.kind == .SCOPE_MODULE
		module_scope = true
	else {
		assert(token.kind == .SCOPE_EXPORT)
		module_scope = false
	}

	advance(parser)
}

parse_load_or_import :: (using parser: *Parser) -> *Node_Load {
	load := create_node(parser, Node_Load)

	if token.kind == .IMPORT
		load.kind = .IMPORT
	else
		assert(token.kind == .LOAD)

	advance(parser)

	load.value = parse_expr(parser)
	if !load.value
		return null

	copy_loc_end(load, load.value)
	return load
}

parse_expr :: (using parser: *Parser) -> *Node {
	return parse_binary_operator(parser)
}

parse_binary_operator :: (using parser: *Parser, precedence := 0) -> *Node {
	BINOP_PRECEDENCES :: []Token.Kind.[
		.[.LOGIC_OR, .LOGIC_AND], 
		.[.EQUAL, .NOT_EQUAL, cast() '>', .LESS_EQUAL, cast() '<', .GREATER_EQUAL], 
		.[.SHIFT_LEFT, .SHIFT_RIGHT], 
		.[cast() '|', cast() '&', cast() '^'], 
		.[cast() '+', cast() '-'], 
		.[cast() '*', cast() '/', cast() '%']
	]

	if precedence == BINOP_PRECEDENCES.count {
		return parse_prefix_operator(parser)
	}

	left := parse_binary_operator(parser, precedence + 1)

	if !left
		return null

	while true {
		for BINOP_PRECEDENCES[precedence] {
			if token.kind == it
				break
		} or {
			break
		}

		binary := create_node(parser, Node_Binary_Operator)

		binary.left = left
		binary.op = token.kind

		copy_loc_start(binary, left)

		advance(parser)

		binary.right = parse_binary_operator(parser, precedence + 1)

		if !binary.right
			return null

		copy_loc_end(binary, binary.right)

		left = binary
	}

	return left
}

parse_prefix_operator :: (using parser: *Parser) -> *Node {
	if token.kind ==  {
	case cast() '+'  #through
	case cast() '-'  #through
	case cast() '!'  #through
	case cast() '~'  #through
	case cast () '*' #through
	case .SHIFT_LEFT #through
	case .SIZE_OF    #through
	case .ALIGN_OF   #through
	case .TYPE_INFO  #through
	case .TYPE_OF    #through	
	case .IS_CONSTANT
		unary := create_node(parser, Node_Unary_Operator)
		unary.op = token.kind

		advance(parser)

		unary.value = parse_prefix_operator(parser)
		if !unary.value
			return null

		copy_loc_end(unary, unary.value)

		return unary
	case .CAST
		binary := create_node(parser, Node_Binary_Operator)
		binary.op = token.kind

		advance(parser)

		while consume(parser, ',') {
			if token.kind != .IDENTIFIER {
				report_expected_error(token, "Error: Expected modifier after ',' in cast")
				return null
			}

			if token.text == {
			case "bit"
				if binary.flags & .CAST_IS_BITWISE {
					report_error(token, "Error: Duplicate modifier 'bit' in cast")
					return null
				}

				binary.flags |= .CAST_IS_BITWISE
				advance(parser)
			else
				report_error(token, "Error: Unknown modifier % for cast", token.text)
				return null	
			}
		}

		if !consume(parser, '(') {
			report_expected_error(token, "Error: Expected '(' in cast")
		}

		if !consume(parser, ')') {
			binary.left = parse_expr(parser)
			if !binary.left
				return null

			if !consume(parser, ')') {
				report_expected_error(token, "Error: Expected ')' after cast target type")
			}
		}

		binary.right = parse_prefix_operator(parser)
		if !binary.right
			return null

		copy_loc_end(binary, binary.right)

		return binary
	case cast() '['
		array := create_node(parser, Node_Binary_Operator)
		array.op = cast() ']' // '[' is already used for array[index]

		advance(parser)

		if consume(parser, .DOUBLE_DOT) {
			array.flags |= .ARRAY_TYPE_DYNAMIC
		} else if token.kind != cast() ']' {
			array.left = parse_expr(parser)
			if !array.left
				return null
		}

		if !consume(parser, ']') {
			report_error(token, "Error: Expected ']' after array dimension")
			return null
		}

		array.right = parse_prefix_operator(parser)

		if !array.right
			return null

		copy_loc_end(array, array.right)


		// @Hack Fix the precedence for []T.[ ... ] and []T.{ ... } so that is parses as ([]T).[ ... ]
		// instead of [](T.[ ... ])

		if array.right.kind == .ARRAY_LITERAL {
			literal := cast(*Node_Array_Literal) array.right

			// No transformation needed for [].[ ... ] (this is always a typechecking error anyway)
			if !literal.type_value
				return array

			copy_loc_end(array, literal.type_value)
			copy_loc_start(literal, array)

			array.right = literal.type_value
			literal.type_value = array

			return literal
		} else if array.right.kind == .STRUCT_LITERAL {
			literal := cast(*Node_Struct_Literal) array.right

			// No transformation needed for [].{ ... } (this is always a typechecking error anyway)
			if !literal.type_value
				return array

			copy_loc_end(array, literal.type_value)
			copy_loc_start(literal, array)

			array.right = literal.type_value
			literal.type_value = array

			return literal
		}

		return array

	else
		return parse_postfix_expr(parser)
	}
}

parse_arguments :: (using parser: *Parser) -> []Argument {
	arguments: [..]Argument

	had_named: bool

	while true {
		argument := array_push(*arguments)

		if token.kind == .IDENTIFIER && get_token(parser, 1).kind == cast() '=' {
			argument.name = token.text

			advance(parser)
			advance(parser)
		}

		if consume(parser, .DOUBLE_DOT)
			argument.spread = true

		argument.value = parse_expr(parser)
		if !argument.value
			return .{}

		if !consume(parser, ',')
			break
	}

	return arguments
}

parse_postfix_expr :: (using parser: *Parser) -> *Node {
	expr := parse_primary_expr(parser)

	if !expr
		return null

	while true {
		if consume(parser, '(') {
			call := create_node(parser, Node_Function_Call)
			copy_loc_start(call, expr)

			if context_available
				call.flags |= .CONTEXT_AVAILABLE
			
			if consume(parser, ')') {
				copy_loc_end(call, previous_token_loc)
			} else {

				call.arguments = parse_arguments(parser)

				 // parse_arguments is only called for non-empty arguments lists so an empty return array indicates an error
				if !call.arguments
					return null
			}

			expr = call
		} else if consume(parser, '[') {
			if consume(parser, .DOUBLE_DOT) {
				slice := create_node(parser, Node_Slice)
				copy_loc_start(slice, expr)
				slice.array = expr

				if token.kind == cast() ']' {
					copy_loc_end(slice, token)
					report_error(slice, "Error: Slice must have at least one bound")
					return null
				}

				slice.end = parse_expr(parser)

				if !slice.end
					return null

				copy_loc_end(slice, token)

				if !consume(parser, ']') {
					report_expected_error(token, "Error: Expected ']' after slice end")
				}

				expr = slice
			} else {
				index := parse_expr(parser)

				if !index
					return null

				if consume(parser, .DOUBLE_DOT) {
					slice := create_node(parser, Node_Slice)
					copy_loc_start(slice, expr)
					slice.array = expr
					slice.begin = index

					if token.kind != cast() ']'{
						slice.end = parse_expr(parser)

						if !slice.end
							return null
					}

					copy_loc_end(slice, token)

					if !consume(parser, ']') {
						report_expected_error(token, "Error: Expected ']' after slice end")
					}

					expr = slice
				} else if consume(parser, ']') {
					binary := create_node(parser, Node_Binary_Operator)
					binary.op = cast() '['
					copy_loc(binary, expr, previous_token_loc)

					binary.left = expr
					binary.right = index

					expr = binary
				}
			}
		} else if consume(parser, '.') {
			report_error(token, "Error: . postfix is not implemented")
			return null
		} else {
			return expr
		} 
	}
}

parse_struct_statement :: (using parser: *Parser) -> (#must *Node, #must bool) {
	if token.kind == .STATIC_IF {
		statement := parse_if(parser, statement_kind = .STRUCT)

		return statement, statement != null
	} else if consume(parser, ';') {
		return null, true
	} else {
		statement := parse_declaration(parser)

		return statement, statement != null
	}
}

create_type_literal :: (using parser: *Parser, type_value: *Type) -> *Node_Literal {
	literal := create_node(parser, Node_Literal)
	literal.kind = .TYPE_LITERAL
	literal.node_type = *TYPE_TYPE
	literal.type_value = type_value

	return literal
}

create_int_literal :: (using parser: *Parser, value: u64, type_: *Type) -> *Node_Literal {
	literal := create_node(parser, Node_Literal)
	literal.kind = .INT_LITERAL
	literal.node_type = type_
	literal.unsigned_value = value

	return literal
}

is_function_header :: (using parser: *Parser) -> bool {
	if token.kind == cast() ')'
		return true


	if check_for_named_arguments(parser)
		return true

	paren_count := 0

	for tokens {
		if it.kind == {
		case cast() ')'
			if paren_count == 0
				break;

			paren_count -= 1
		case cast() '('
			paren_count += 1
		case cast() ','
			if paren_count == 0
				return true

		}
	} or {
		return false
	}

	return token.kind == .ARROW || token.kind == .EXTERNAL || token.kind == .COMPILER || 
		   token.kind == .C_CALL || token.kind == .INTRINSIC
}

check_for_named_arguments(using parser: *Parser) -> bool {
	index := 0

	if get_token(parser, index) == .MUST
		index += 1

	if get_token(parser, index) == .USING
		index += 1

	if get_token(parser, index) == cast() '$'
		index += 1

	return get_token(parser, index    ).kind == .IDENTIFIER && 
		   get_token(parser, index + 1).kind == cast() ':'
}

parse_function_or_function_type :: (using parser: *Parser, start: Location, allow_body: bool) -> *Node_Function {
	function := create_node(parser, Node_Fucntion)
	copy_loc_start(function, start)

}

parse_primary_expr :: (using parser: *Parser) -> *Node {
	start := token.loc


	if token.kind == {
	case cast() '('
		advance(parser)

		if is_function_header(parser) {
			return parse_function_or_function_type(parser, start, allow_body = true)
		} else {
			expr := parse_expr(parser)

			if !consume(parser, ')') {
				report_error(token, "Error: Expected ')' after expression")
			}
			return expr
		}
	case cast() '.'
		report_error(token, "Error: Unary dot is not implemented")
		return null
	case .IDENTIFIER
		identifier := create_node(parser, Node_Identifier)
		identifier.text = token.text
		identifier.resolving_from = identifier.enclosing_block
		advance(parser)

		return identifier
	case cast() '$'
		report_error(token, "Error: Polymorph variable parsing is not supported")
		return null
	case .FLOAT_LITERAL
		literal := create_node(parser, Node_Literal)
		literal.kind = .FLOAT_LITERAL
		literal.float_value = token.float

		advance(parser)
		return literal
	case .INT_LITERAL
		literal := create_int_literal(parser, token.integer, null)

		advance(parser)
		return literal
	case .CONTEXT
		if !current_block || current_block.kind != .IMPERATIVE {
			report_error(token, "Error: Cannot refer to the context from outside an imperative scope")
			return null
		}

		if !context_available {
			report_error(token, "Error: No context is passed to a #c_call function, use push_context to get one")
			return null
		}

		expr := create_node(parser, Node)
		expr.kind = .CONTEXT
		expr.node_type = *TYPE_CONTEXT

		advance(parser)
		return expr
	case .ENTRY_POINT
		expr := create_node(parser, Node)
		expr.kind = .ENTRY_POINT

		advance(parser)
		return expr
	case .FALSE
		literal := create_int_literal(parser, 0, *TYPE_BOOL)

		advance(parser)
		return literal
	case .TRUE
		literal := create_int_literal(parser, 1, *TYPE_BOOL)

		advance(parser)
		return literal
	case .NULL
		literal := create_int_literal(parser, 0, *TYPE_MEMORY)

		advance(parser)
		return literal
	case .STRING_LITERAL
		literal := create_node(parser, Node)
		literal.kind = .STRING_LITERAL
		literal.text = token.text

		advance(parser)
		return literal
	case .U8
		return type_literal_helper(parser, *TYPE_U8)
	case .U16
		return type_literal_helper(parser, *TYPE_U16)
	case .U32
		return type_literal_helper(parser, *TYPE_U32)
	case .U64
		return type_literal_helper(parser, *TYPE_U64)
	case .S8
		return type_literal_helper(parser, *TYPE_S8)
	case .S16
		return type_literal_helper(parser, *TYPE_S16)
	case .S32
		return type_literal_helper(parser, *TYPE_S32)
	case .S64
		return type_literal_helper(parser, *TYPE_S64)
	case .F32
		return type_literal_helper(parser, *TYPE_F32)
	case .F64
		return type_literal_helper(parser, *TYPE_F64)
	case .BOOL
		return type_literal_helper(parser, *TYPE_BOOL)
	case .TYPE
		return type_literal_helper(parser, *TYPE_TYPE)
	case .MEMORY
		return type_literal_helper(parser, *TYPE_MEMORY)
	case .STRING
		return type_literal_helper(parser, *TYPE_STRING)	
	case .CONTEXT_TYPE
		return type_literal_helper(parser, *TYPE_CONTEXT)
	case .STRUCT #through
	case .UNION
		struct_ := create_node(parser, Node_Struct_Definition)
		struct_.defined_type.definition = struct_

		if token.kind == .UNION
			struct_.defined_type.flags |= .UNION

		advance(parser)

		push_block(parser, *struct_.block)

		if consume(parser, .PACK)
			struct_.defined_type.flags |= .PACKED

		if !consume(parser, '{') {
			report_expected_error(token, "Error: Expected '{' in struct definition")
			return null
		}

		statements:  [..]*Node

		while true {
			if consume(parser, '}') {
				break
			}

			statement, success := parse_struct_statement(parser)

			if !success
				return null

			if statement
				array_add(*statements, statement)
		}

		struct_.statements = statements

		pop_block(parser)

		copy_loc_end(struct_, previous_token_loc)

		return struct_
	case .IMPORT
		return parse_load_or_import(parser)
	case .ENUM #through
	case .ENUM_FLAGS
		report_error(token, "Error: Enum parsing is not implemented")
		return null
	case .RUN
		return parse_run(parser)
	else
		report_expected_error(token, "Error: Expected an expression")
		return null
	}

	type_literal_helper :: (using parser: *Parser, type_value: *Type) -> *Node_Literal {
		literal := create_type_literal(parser, type_value)
		advance(parser)
		return literal

	}
}

push_function :: (using parser: *Parser, function: *Node_Function, has_context: bool) -> #must Function_State {
	old_state := function_state
	current_function  = function
	current_defer     = null
	context_available = has_context

	return old_state
}

pop_function :: (using parser: *Parser, old_state: Function_State) {
	function_state = old_state
}

push_block :: (using parser: *Parser, block: *Block) {
	block.parent = current_block
	current_block = block

}

pop_block :: (using parser: *Parser) {
	current_block = current_block.parent
}

parse_run :: (using parser: *Parser) -> *Node_Run {
	assert(token.kind == .RUN)

	node := create_node(parser, Node_Run)
	advance(parser)

	old_state := push_function(parser, null, has_context = true)

	if token.kind == cast() '{'
		node.value = parse_block(parser, statement_kind = .IMPERATIVE, is_case = false)
	else
		node.value = parse_expr(parser)

	pop_function(parser, old_state)

	if !node.value
		return null

	copy_loc_end(node, node.value)
	return node
}

Statement_Kind :: enum u8 {
	TOP_LEVEL
	IMPERATIVE
	STRUCT
}

parse_if :: (using parser: *Parser, statement_kind: Statement_Kind) -> *Node_If {
	if_ := create_node(parser, Node_If)
	
	if token.kind == .STATIC_IF
		if_.kind = .STATIC_IF
	else
		assert(token.kind == .IF)

	advance(parser)

	if_.condition = parse_expr(parser)

	if !if_.condition
		return null

	copy_loc_end(if_, if_.condition)	

	success: bool = --

	if_.if_body, success = parse_block_or_statement(parser, statement_kind)

	if !success
		return null

	if token.kind == .ELSE {
		advance(parser)

		if_.else_body, success = parse_block_or_statement(parser, statement_kind)

		if !success
			return null
	}

	return if_
}

parse_block_or_statement :: (using parser: *Parser, statement_kind: Statement_Kind) -> (#must *Node, #must bool) {
	previous_module_scope := module_scope
	defer module_scope = previous_module_scope

	if token.kind == cast() '{' {
		block := parse_block(parser, statement_kind, is_case = false)
		return block, block != null
	} else if token.kind == cast() ';' {
		return null, true
	} else if statement_kind == #complete {
	case .TOP_LEVEL
		statement, success := parse_top_level_statement(parser)

		return statement, success
	case .IMPERATIVE
		statement := parse_statement(parser)

		return statement, statement != null
	case .STRUCT
		statement, success := parse_struct_statement(parser)

		return statement, success
	else
		return null, false
	}
}

parse_add_context :: (using parser: *Parser) -> *Node_Add_Context {
	assert(token.kind == .ADD_CONTEXT)

	node := create_node(parser, Node_Add_Context)
	advance(parser)

	node.declaration = parse_declaration(parser)
	if !node.declaration
		return null

	return node
}

parse_block :: (using parser: *Parser, statement_kind: Statement_Kind, is_case: bool) -> *Node_Block {
	assert(is_case || token.kind == cast() '{')

	block := create_node(parser, Node_Block)

	push_block(parser, *block.declarations)
	defer pop_block(parser)

	if !is_case
		advance(parser)

	exiting_statement := false

	statements: [..]*Node

	while true {
		if is_case {
			if token.kind == .CASE || token.kind == .ELSE || token.kind == .THROUGH || token.kind == cast() '}'
				break
		} else {
			if token.kind == cast() '}' {
				advance(parser)
				break
			}
		}

		if exiting_statement {
			report_error(token, "Error: Unreachable statements in block")
			return null
		}

		if is_case && token.kind == .THROUGH
			break;

		statement: *Node = --

		if token.kind ==  {
		case .USING
			statement = parse_declaration_or_using(parser)
			if !statement
				return null
		case .DEFER
			if statement_kind != .IMPERATIVE
				report_error(token, "Error: Cannot only have a defer in an imperative scope")

			defer_ := create_node(parser, Node_Unary_Operator)
			defer_.kind = .DEFER
			statement = defer_

			old_defer := current_defer
			current_defer = defer_
			advance(parser)

			success: bool = --
			defer_.value, success = parse_block_or_statement(parser, statement_kind)

			current_defer = old_defer

			if !success
				return null

			copy_loc_end(defer_, defer_.value)

			if !defer_.value {
				report_error(defer_, "Error: Cannot have an empty defer")
				return null
			};
		case cast() ';'
			advance(parser)
			continue
		else
			if statement_kind == .STRUCT && token.kind == cast() '{' {
				report_error(token, "Error: Cannot have a local block within a struct definition")
				return null
			}

			success: bool = --
			statement, success = parse_block_or_statement(parser, statement_kind)
			if !success
				return null

		}

		exiting_statement = false

		if statement {
			array_add(*statements, statement)

			if statement.kind == .RETURN || statement.kind == .BREAK || statement.kind == .CONTINUE {
				exiting_statement = true
			}
		}
	}

	copy_loc_end(block, previous_token_loc)
	block.statements = statements

	return block
}

parse_statement :: (using parser: *Parser) -> *Node {
	if token.kind == {
	case .FOR
		return parse_for(parser)
	case .WHILE
		return parse_while(parser)
	case .IF #through
	case .STATIC_IF
		return parse_if(parser, statement_kind = .IMPERATIVE)
	case .PUSH_CONTEXT
		return parse_push_context(parser)
	case .CONTINUE #through
	case .BREAK    #through
	case .REMOVE
		return parse_loop_control(parser)
	case .RETURN
		return parse_return(parser)
	case .USING
		report_error(token, "Error: Cannot have a lone using statement")
		return null
	case .IDENTIFIER
		if get_token(parser, 1).kind == cast() ':' {
			return parse_declaration(parser)
		}

		#through
	else
		return parse_expr_statement(parser)
	}
}

parse_for :: (using parser: *Parser) -> *Node_Loop {
	assert(token.kind == .FOR)

	loop := create_node(parser, Node_Loop)

	advance(parser)

	

	report_error(token, "parse_for not implemented")
	return null
}

parse_while :: (using parser: *Parser) -> *Node_Loop {
	report_error(token, "parse_while not implemented")
	return null
}

parse_push_context :: (using parser: *Parser) -> *Node_Binary_Operator {
	report_error(token, "parse_push_context not implemented")
	return null
}

parse_loop_control :: (using parser: *Parser) -> *Node_Loop_Control {
	report_error(token, "parse_loop_control not implemented")
	return null
}

parse_return :: (using parser: *Parser) -> *Node_Function_Call {
	report_error(token, "parse_return not implemented")
	return null
}

parse_expr_statement :: (using parser: *Parser) -> *Node {
	report_error(token, "parse_expr_statement not implemented")
	return null
}