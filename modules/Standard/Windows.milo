#import "Windows"
#import "String"

allocate :: (size: u64) -> #must *void {
	init_process_heap()
	return HeapAlloc(process_heap, 0, size)
}



reallocate :: (block: *void, size: u64) -> #must *void {
	if block == null
		return allocate(size)
	else {			
		init_process_heap()
		return HeapReAlloc(process_heap, 0, block, size)
	}
}

deallocate :: (block: *void) {
	init_process_heap()
	HeapFree(process_heap, 0, block)
}

default_allocator :: (mode: Allocator.Mode, allocator_data: *void, size: u64, alignment: u64, pointer: *void, old_size: u64) -> *void {
	init_process_heap()

	if mode == #complete {
		case .NEW
			return HeapAlloc(process_heap, 0, size)
		case .EXPAND
			if !pointer
				return HeapAlloc(process_heap, 0, size)
			else
				return HeapReAlloc(process_heap, 0, pointer, size)
		case .FREE
			HeapFree(process_heap, 0, pointer)
			return null
		case .FREE_ALL #through
		else
			assert(false)
			return null
	}
}

exit :: (code: u32 = 0) {
	ExitProcess(code)
}

// @Unicode
print_buffer :: (buffer: []u8) {
	init_std_out()
	bytes_written: u32
	WriteFile(std_out, buffer.data, cast() buffer.count, *bytes_written)
}

print_buffer :: (c: *Concatenator) {
	init_std_out()
	bucket := c.current_bucket
	
	while bucket {
		bytes_written: u32
		WriteFile(std_out, bucket.data.data, cast() bucket.offset, *bytes_written)
		
		bucket = bucket.next
	}
}

get_command_line_arguments :: () -> []string {
	count: s32

	windows_args := CommandLineToArgvW(GetCommandLineW(), *count)
	
	if !windows_args {
		return .{}
	}
	
	args := []string.{allocate(size_of(string) * cast(u64) count), cast() count}
	
	for * args {
		<<it = from_windows_string(windows_args[it_index])
	}

	return args
}

run_command_asyncs :: (command: string) -> bool {
	startup: STARTUPINFOW
	
	info: PROCESS_INFORMATION = --
	
	windows_command := to_windows_string(command)
	defer deallocate(windows_command)
	
	if !CreateProcessW(lpCommandLine = windows_command, lpStartupInfo = *startup, lpProcessInformation = *info)
		return false
	
	CloseHandle(info.hThread)
	CloseHandle(info.hProcess)
	
	return true
}

run_command :: (command: string) -> u32 {
	startup: STARTUPINFOW
	
	info: PROCESS_INFORMATION = --
	
	windows_command := to_windows_string(command)
	defer deallocate(windows_command)
	
	if !CreateProcessW(lpCommandLine = windows_command, lpStartupInfo = *startup, lpProcessInformation = *info, bInheritHandles = 1)
		return cast() -1
	
	CloseHandle(info.hThread)
	
	WaitForSingleObject(info.hProcess)
	
	exit_code: u32 = --
	
	if !GetExitCodeProcess(info.hProcess, *exit_code)
		return cast() -2
	
	CloseHandle(info.hProcess)
	
	return exit_code
}

enable_console_colors :: () -> bool {
	init_std_out()
	
	if (std_out != INVALID_HANDLE_VALUE) {
		mode: Console_Mode

		if GetConsoleMode(std_out, *mode) {
			if SetConsoleMode(std_out, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING) {
				return true
			}
		}
	}
	
	return false
}

 // @Incomplete: This is probably the slowest read_line function ever written, what is the correct way to do this in win32?
read_line :: () -> (string, bool) {
	init_std_in()

	result: [..]u8

	while true {
		c: u8
		bytes_read: u32

		if !ReadFile(std_in, *c, 1, *bytes_read, null) || bytes_read == 0
			break

		if c == '\n' {
			if had_carriage_return {
				had_carriage_return = false
				continue
			}
		}

		had_carriage_return = c == '\r'


		if c == '\n' || c == '\r' {
			return .{result.data, result.count}, true
		}

		array_add(*result, c)
	}

	return "", false
}

#scope_module

had_carriage_return: bool

input_buffer: []u8
input_buffer_data: [4096]u8

std_in: HANDLE
std_out: HANDLE
process_heap: HANDLE

init_std_out :: () {
	if !std_out {
		std_out = GetStdHandle(STD_OUTPUT_HANDLE)
		SetConsoleOutputCP(CP_UTF8)
	}
}

init_std_in :: () {
	if !std_in {
		std_in = GetStdHandle(STD_INPUT_HANDLE)
		SetConsoleOutputCP(CP_UTF8)
	}
}

init_process_heap :: () {
	if !process_heap  process_heap = GetProcessHeap()
}