clamp01 :: (x: f32) -> f32 {
	if x > 1
		return 1
	else if x < 0
		return 0
	else
		return x
}

Ray :: struct {
	origin:    Vector3
	direction: Vector3
}

add :: (a: Vector3, b: Vector3) -> Vector3 {
	return .{.{a.x + b.x, a.y + b.y, a.z + b.z}}
}

sub :: (a: Vector3, b: Vector3) -> Vector3 {
	return .{.{a.x - b.x, a.y - b.y, a.z - b.z}}
}

modulate :: (a: Vector3, b: Vector3) -> Vector3 {
	return .{.{a.x * b.x, a.y * b.y, a.z * b.z}}
}

scale :: (t: f32, using v: Vector3) -> Vector3 {
	return .{.{t * x, t * y, t * z}}
}

lerp :: (t: f32, a: Vector3, b: Vector3) -> Vector3 {
	return add(scale(1 - t, a), scale(t, b));
}

dot :: (a: Vector3, b: Vector3) -> f32 {
	return a.x * b.x + a.y * b.y + a.z * b.z
}

neg :: (using v: Vector3) -> Vector3 {
	return .{.{-x, -y, -z}}
}

length :: (v: Vector3) -> f32 {
	return sqrtf(dot(v, v))
}

unit :: (v: Vector3) -> Vector3 {
	len := length(v)

	return scale(1 / len, v)
}

cross :: (a: Vector3, b: Vector3) -> Vector3 {
	return .{.{
		a.y * b.z - a.z * b.y, 
		a.z * b.x - a.x * b.z, 
		a.x * b.y - a.y * b.x
	}}
}

reflect :: (v: Vector3, normal: Vector3) -> Vector3 {
	return sub(v, scale(2 * dot(v, normal), normal));
}

ray :: (t: f32, r: Ray) -> Vector3 {
	return add(r.origin, scale(t, r.direction))
}

hit_sphere :: (using r: Ray, using sphere: Sphere, t_min: f32) -> f32 {
	dist := sub(center, origin)

	a := dot(direction, direction)
	minus_half_b := dot(dist, direction)
	c := dot(dist, dist) - radius * radius

	discriminant := minus_half_b * minus_half_b - a * c

	if discriminant < 0
		return t_min - 1e9


	sqrt := sqrtf(discriminant)
	root := (minus_half_b - sqrt) / a

	if root < t_min
		return (minus_half_b + sqrt) / a

	return root
}

#add_context random_state: u32

random_u32 :: () -> u32 {
	x := context.random_state
	x ^= x << 13
	x ^= x >> 17
	x ^= x << 5
	context.random_state = x + 1
	return x
}

random_f32 :: () -> f32 {
	return cast(f32) random_u32() * 0x1p-32
}

random_bilateral :: () -> f32 {
	return random_f32() * 2 - 1
}

random_unit :: () -> Vector3 {
	while true {
		v := Vector3.{.{random_bilateral(), random_bilateral(), random_bilateral()}}

		if dot(v, v) <= 1
			return unit(v)
	}
}

random_in_unit_disk :: () -> Vector3 {
	while true {
		v := Vector3.{.{random_bilateral(), random_bilateral(), 0}}

		if dot(v, v) <= 1
			return v
	}
}

sqrtf :: (x: f32) -> f32 #external "c"
tanf :: (x: f32) -> f32 #external "c"