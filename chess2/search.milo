perft :: (using state: State, depth: s8) -> s64 {
	if depth == 0
		return 1

	moves_buffer: [200]Move = --
	moves := backed_array(moves_buffer)

	get_all_moves(state, *moves)

	nodes := 0

	for moves {
		new_state, valid := checked_do_move(state, it)

		if valid {
			nodes += perft(new_state, depth - 1)
		}
	}

	return nodes
}

killer_moves: [MAX_DEPTH * 3]Move
history: [12][64]f32
counter_move: [12][64]Move

add_history :: (value: *f32, bonus: f32) {
	MAX_HISTORY_BONUS :: 10;
	
	<<value += bonus - <<value * bonus / MAX_HISTORY_BONUS
}

remove_history :: (value: *f32, penalty: f32) {
	MAX_HISTORY_BONUS :: 10;
	
	<<value -= penalty - <<value * penalty / MAX_HISTORY_BONUS
}

order_moves :: (using state: State, moves: []Move, best_move: Move, killer_move: Move, depth: s64, alpha: s16, beta: s16) {
	evaluation_list: [200]s64 = --
	
	for moves {
		evaluation_list[it_index] = 0
		
		if moves_equal(it, best_move) {
			evaluation_list[it_index] = 1_000_000
		} else if moves_equal(it, killer_move) {
			evaluation_list[it_index] = 900_000
		} else if moves_equal(it, counter_move[previous_move.start_piece][previous_move.end]) {
			evaluation_list[it_index] = 800_000
		} else if is_capture_move(state, it) {
			captured := get_piece(state, it.end)


			if captured != -1 {
				evaluation_list[it_index] -= piece_values[it.start_piece][it.start] + piece_values[captured][it.end]
			}

			if it.end_piece > it.start_piece {
				evaluation_list[it_index] += piece_values[it.end_piece][it.end] - piece_values[it.start_piece][it.start]
			}

			if !state.white_move {
				evaluation_list[it_index] = -evaluation_list[it_index]
			}

			evaluation_list[it_index] += 10000
		} else if depth > 3 {
			evaluation_list[it_index] = cast() minimax(state, depth - 2, alpha, beta)
		}
		
		evaluation_list[it_index] += cast() (history[it.start_piece][it.end])
	}

	for moves {
		i := it_index
		
		while i >= 1 {
			a := evaluation_list[i - 1]
			b := evaluation_list[i]
		
			if a >= b
				break;
			
			evaluation_list[i] = a
			evaluation_list[i - 1] = b
			
			moves[i] = moves[i - 1]
			moves[i - 1] = it
			
			i -= 1
		}
	}
}

MAX_DEPTH :: 50

moves_explored: u64

transposition_table: [1 << 18]struct {
	hash: u64
	value: s16
	kind: enum u8 {
		LOWER_BOUND
		UPPER_BOUND
		EXACT
	}
	depth: s8
	ply: s16
	move: Move
}

max_moves: u64 = 7_500_000

stats: struct {
	beta_cutoffs: u64
	transpositions_matched: u64
}

quiesce :: (using state: State, alpha: s16, beta: s16, depth: s64 = 0) -> s16 {
	if moves_explored == max_moves {
		return 0
	}

	best_move := Move.{start_piece = -1}
	current_alpha := alpha
	current_beta := beta

	if move_count >= 100 {
		current_alpha = min(max(current_alpha, 0), current_beta)
		return current_alpha
	}

	for move_count {
		if state_history.count < cast() (it + 1)
			break;

		if state_history[state_history.count - 1 - cast() it] == hash {
			current_alpha = min(max(current_alpha, 0), current_beta)
			return current_alpha
		}
	}

	moves_explored += 1
	
	entry := *transposition_table[hash & (transposition_table.count - 1)]
	

	if entry.hash == hash && entry.depth >= depth {
		if entry.value > 19000 {
			entry.value = entry.value + entry.ply - ply
			entry.ply = ply
		} else if entry.value < -19000 {
			entry.value = entry.value - entry.ply + ply
			entry.ply = ply
		}

		stats.transpositions_matched += 1
	
		if entry.kind == .EXACT {
			return entry.value
		} else if entry.kind == .LOWER_BOUND {
			best_move = entry.move
			current_alpha = max(entry.value, current_alpha)
		} else if entry.kind == .UPPER_BOUND {
			current_beta = min(current_beta, entry.value)
		}
		
		if current_alpha >= current_beta {
			stats.beta_cutoffs += 1
			return current_beta
		}
	}

	defer {
		if current_alpha > current_beta {
			current_beta = current_alpha
		}

		if entry && moves_explored < max_moves {

			entry.value = current_alpha
			entry.hash = hash
			entry.move = best_move
			entry.ply = ply
			entry.depth = cast() depth
			
			if current_alpha <= alpha
				entry.kind = .UPPER_BOUND
			else if current_alpha >= current_beta
				entry.kind = .LOWER_BOUND
			else
				entry.kind = .EXACT
		}
	}

	in_check := is_in_check(state)

	if !in_check {
		if white_move {
			current_alpha = max(current_alpha, evaluate_position(state))
		} else {
			current_alpha = max(current_alpha, -evaluate_position(state))
		}

		if current_alpha >= current_beta {
			stats.beta_cutoffs += 1
			current_alpha = current_beta
			return current_alpha
		}
	}



	killer_move := *killer_moves[killer_moves.count - 1 + depth]


	moves_buffer: [200]Move = --
	moves := backed_array(moves_buffer)

	if in_check {
		get_all_moves(state, *moves)
	} else {
		get_capture_moves(state, *moves)
	}

	order_moves(state, moves, best_move, <<killer_move, depth, current_alpha, current_beta)

	had_legal := false

	array_add(*state_history, hash)
	defer array_pop(*state_history)
	for moves {
		new_state, valid := checked_do_move(state, it)

		if !valid
			continue;
		

		score: s16
		if !had_legal {
			score = -quiesce(new_state, -current_beta, -current_alpha, depth - 1)
		} else {
			score = -quiesce(new_state, -current_alpha - 1, -current_alpha, depth - 1)

			if score > current_alpha
				score = -quiesce(new_state, -current_beta, -current_alpha, depth - 1)
		}

		had_legal = true


		if score > current_alpha {
			best_move = it
			current_alpha = score
		}

		if current_alpha >= current_beta {
			stats.beta_cutoffs += 1
			current_alpha = current_beta;
			<<killer_move = it

			if !is_capture_move(state, it)
				counter_move[previous_move.start_piece][previous_move.end] = it

			return current_alpha
		}

	}

	if !had_legal {
		if in_check {
			current_alpha = max(current_alpha, -20000 + cast(s16) ply)
		}
	}

	return current_alpha
}


minimax :: (using state: State, depth: s64, alpha: s16 = -30000, beta: s16 = 30000, root := false) -> (s16, Move) {
	if moves_explored == max_moves {
		return 0, .{start_piece = -1}
	}

	moves_explored += 1
	
	best_move := Move.{start_piece = -1}
	current_alpha := alpha
	current_beta := beta

	if !root {
		if move_count >= 100 {
			current_alpha = min(max(current_alpha, 0), current_beta)
			return current_alpha, best_move
		}

		for move_count {
			if state_history.count < cast() (it + 1)
				break;

			if state_history[state_history.count - 1 - cast() it] == hash {
				current_alpha = min(max(current_alpha, 0), current_beta)
				return current_alpha, best_move
			}
		}
	}
	
	entry := *transposition_table[hash & (transposition_table.count - 1)]

	if entry.hash == hash && entry.depth >= depth && (!root || entry.move.start_piece != -1) {
		if entry.value > 19000 {
			entry.value = entry.value + entry.ply - ply
			entry.ply = ply
		} else if entry.value < -19000 {
			entry.value = entry.value - entry.ply + ply
			entry.ply = ply
		}

		stats.transpositions_matched += 1
	
		if entry.kind == .EXACT {
			return entry.value, entry.move
		} else if entry.kind == .LOWER_BOUND {
			best_move = entry.move
			current_alpha = max(entry.value, current_alpha)
		} else if entry.kind == .UPPER_BOUND {
			current_beta = min(current_beta, entry.value)
		}
		
		if current_alpha >= current_beta {
			current_alpha = current_beta
			stats.beta_cutoffs += 1
			return current_alpha, best_move
		}
	}

	defer {
		if current_alpha >= current_beta {
			current_alpha = current_beta
		}

		if entry && moves_explored < max_moves  {

			entry.value = current_alpha
			entry.hash = hash
			entry.depth = cast() depth
			entry.move = best_move
			entry.ply = ply
			
			if current_alpha <= alpha
				entry.kind = .UPPER_BOUND
			else if current_alpha >= current_beta
				entry.kind = .LOWER_BOUND
			else
				entry.kind = .EXACT
		}
	}

	if depth == 0 {
		current_alpha = quiesce(state, current_alpha, beta)
	} else {

		in_check := is_in_check(state)

		killer_move := *killer_moves[depth]

		legal_moves := 0
		
		moves_buffer: [200]Move = --
		moves := backed_array(moves_buffer)
		get_all_moves(state, *moves)
		order_moves(state, moves, best_move, <<killer_move, depth, current_alpha, current_beta)

		array_add(*state_history, hash)
		defer array_pop(*state_history)
		for moves {
			new_state, valid := checked_do_move(state, it)

			if !valid
				continue;


			score: s16

			if !legal_moves {
				score = -minimax(new_state, depth - 1, -current_beta, -current_alpha)
			} else {
				reduction := 0

				if !in_check && depth > 3 && !is_capture_move(state, it) && legal_moves >= 4 {
					reduction = 1 + cast() (legal_moves >= 10)
				}

				score = -minimax(new_state, depth - 1 - reduction, -current_alpha - 1, -current_alpha)

				if score > current_alpha && reduction
					score = -minimax(new_state, depth - 1, -current_alpha - 1, -current_alpha)

				if score > current_alpha
					score = -minimax(new_state, depth - 1, -current_beta, -current_alpha)
			}

			legal_moves += 1

			history_location := *history[it.start_piece][it.end]

			if score > current_alpha {
				best_move = it
				current_alpha = score

				add_history(history_location, 0.01 * cast(f32) depth)

				if current_alpha >= current_beta {
					add_history(history_location, 0.01 * cast(f32) depth * cast(f32) depth)
					current_alpha = current_beta
					stats.beta_cutoffs += 1;
					<<killer_move = it

					if !is_capture_move(state, it)
						counter_move[previous_move.start_piece][previous_move.end] = it

					return current_alpha, best_move
				}
			} else {
				remove_history(history_location, 0.01 * cast(f32) depth)
			}
		}

		if !legal_moves {
			if in_check 
				current_alpha = max(current_alpha, -20000 + cast(s16) ply)
			else
				current_alpha = max(current_alpha, 0)

			return current_alpha, best_move
		}
	}

	return current_alpha, best_move
}

rng: Random_State

select_ai_move :: () -> Move {
	if use_book {
		// Try and use a book move for the first 6 moves
		if global_board.ply < 12 {			
			book := opening_table_lookup(global_board.hash)
			
			if !book {
				print("Position not found in opening book\n")
			} else {
				print("Playing book move\n")
				return book.moves[random_u32(*rng) % book.moves.count]
			}
		}
	}

	old_max_moves := max_moves
	// no limit on moves for the first iteration to make sure we always get at least 1
	max_moves = 1_000_000_000

	move_format_buffer: [16]u8

	memory_clear(history.data, size_of(type_of(history)))

	for * killer_moves {
		<<it = .{start_piece = -1}
	}

	stats = .{}
	moves_explored = 0
	
	depth := 1
	value, ai_move := minimax(global_board, cast() depth, root = true)
	print("Depth: % Move: %\n", depth, format_move(global_board, ai_move, move_format_buffer))
	
	total_explored := moves_explored
	
	max_moves = old_max_moves
	
	alpha_aspiraton: s16 = 40
	beta_aspiration: s16 = 40
	
	depth += 1

	while moves_explored < max_moves && depth < MAX_DEPTH {

		new_value, new_move := minimax(global_board, cast() depth, value - alpha_aspiraton, value + beta_aspiration, root = true)
	
		if moves_explored >= max_moves
			break;
	
		total_explored = moves_explored

		if new_value >= value + beta_aspiration {
			beta_aspiration *= 2
			print("Fail high\n")
		} else if new_value <= value - alpha_aspiraton {
			alpha_aspiraton *= 2
			print("Fail low\n")
		} else {
			value = new_value
			ai_move = new_move
			alpha_aspiraton = 40
			beta_aspiration = 40
			print("Depth: % Move: %\n", depth, format_move(global_board, ai_move, move_format_buffer))

			depth += 1
		}
	}

	print("%\n", stats)
	print("% moves explored\n", total_explored)
	print("move valued at %\n", value)
	
	return ai_move
}

ai_start_semaphore: Semaphore
ai_stop_semaphore:  Semaphore

ai_thread_proc :: (thread: *Thread) {
	ai_move := cast(*Move) thread.user_data
	while true {
		wait_semaphore(ai_start_semaphore);
		
		start_time := get_performance_timer();
		<<ai_move = select_ai_move()
		end_time := get_performance_timer()
		
		print("Move took % s\n", end_time - start_time)
		
		notify_semaphore(ai_stop_semaphore)
	}
}

making_ai_move := false
ai_move: Move

make_ai_move ::() {
	if making_ai_move {
		if wait_semaphore(ai_stop_semaphore, 0) {
			if ai_move.start_piece == -1 {
				print("Bad\n")
				game_over = true
			} else {
				make_move(ai_move)
			}
			
			making_ai_move = false
		}
	} else {
		notify_semaphore(ai_start_semaphore)
		making_ai_move = true
	}
}